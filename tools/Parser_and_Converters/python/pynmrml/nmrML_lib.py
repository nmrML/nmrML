#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Dec 18 17:30:45 2013 by generateDS.py version 2.11a.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class nmrMLType(GeneratedsSuper):
    """This is the root element for the COordination Of Standards In
    MetabOlomicS nmrML schema, which is intended to capture the use
    of a nuclear magnetic resonance spectrometer, the data
    generated, and the initial processing of that data (to the level
    of the peak list).The nmrML version used to create the
    document.Optional accession number for the nmrML document. Used
    for storage (for example MetaboLights) Optional attribute for
    retrieva of an nmrML document. Usefull when the document has
    been retrieved from a public database.An optional ID for the
    nmrML document."""
    subclass = None
    superclass = None
    def __init__(self, version=None, accession_url=None, accession=None, id=None, cvList=None, fileDescription=None, contactList=None, referenceableParamGroupList=None, sourceFileList=None, softwareList=None, instrumentConfigurationList=None, dataProcessingList=None, sampleList=None, acquisition=None, spectrumList=None):
        self.version = _cast(None, version)
        self.accession_url = _cast(None, accession_url)
        self.accession = _cast(None, accession)
        self.id = _cast(None, id)
        self.cvList = cvList
        self.fileDescription = fileDescription
        self.contactList = contactList
        self.referenceableParamGroupList = referenceableParamGroupList
        self.sourceFileList = sourceFileList
        self.softwareList = softwareList
        self.instrumentConfigurationList = instrumentConfigurationList
        self.dataProcessingList = dataProcessingList
        self.sampleList = sampleList
        self.acquisition = acquisition
        self.spectrumList = spectrumList
    def factory(*args_, **kwargs_):
        if nmrMLType.subclass:
            return nmrMLType.subclass(*args_, **kwargs_)
        else:
            return nmrMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cvList(self): return self.cvList
    def set_cvList(self, cvList): self.cvList = cvList
    def get_fileDescription(self): return self.fileDescription
    def set_fileDescription(self, fileDescription): self.fileDescription = fileDescription
    def get_contactList(self): return self.contactList
    def set_contactList(self, contactList): self.contactList = contactList
    def get_referenceableParamGroupList(self): return self.referenceableParamGroupList
    def set_referenceableParamGroupList(self, referenceableParamGroupList): self.referenceableParamGroupList = referenceableParamGroupList
    def get_sourceFileList(self): return self.sourceFileList
    def set_sourceFileList(self, sourceFileList): self.sourceFileList = sourceFileList
    def get_softwareList(self): return self.softwareList
    def set_softwareList(self, softwareList): self.softwareList = softwareList
    def get_instrumentConfigurationList(self): return self.instrumentConfigurationList
    def set_instrumentConfigurationList(self, instrumentConfigurationList): self.instrumentConfigurationList = instrumentConfigurationList
    def get_dataProcessingList(self): return self.dataProcessingList
    def set_dataProcessingList(self, dataProcessingList): self.dataProcessingList = dataProcessingList
    def get_sampleList(self): return self.sampleList
    def set_sampleList(self, sampleList): self.sampleList = sampleList
    def get_acquisition(self): return self.acquisition
    def set_acquisition(self, acquisition): self.acquisition = acquisition
    def get_spectrumList(self): return self.spectrumList
    def set_spectrumList(self, spectrumList): self.spectrumList = spectrumList
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_accession_url(self): return self.accession_url
    def set_accession_url(self, accession_url): self.accession_url = accession_url
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.cvList is not None or
            self.fileDescription is not None or
            self.contactList is not None or
            self.referenceableParamGroupList is not None or
            self.sourceFileList is not None or
            self.softwareList is not None or
            self.instrumentConfigurationList is not None or
            self.dataProcessingList is not None or
            self.sampleList is not None or
            self.acquisition is not None or
            self.spectrumList is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='nmrMLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nmrMLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='nmrMLType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.accession_url is not None and 'accession_url' not in already_processed:
            already_processed.add('accession_url')
            outfile.write(' accession_url=%s' % (self.gds_format_string(quote_attrib(self.accession_url).encode(ExternalEncoding), input_name='accession_url'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='nmrMLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cvList is not None:
            self.cvList.export(outfile, level, namespace_, name_='cvList', pretty_print=pretty_print)
        if self.fileDescription is not None:
            self.fileDescription.export(outfile, level, namespace_, name_='fileDescription', pretty_print=pretty_print)
        if self.contactList is not None:
            self.contactList.export(outfile, level, namespace_, name_='contactList', pretty_print=pretty_print)
        if self.referenceableParamGroupList is not None:
            self.referenceableParamGroupList.export(outfile, level, namespace_, name_='referenceableParamGroupList', pretty_print=pretty_print)
        if self.sourceFileList is not None:
            self.sourceFileList.export(outfile, level, namespace_, name_='sourceFileList', pretty_print=pretty_print)
        if self.softwareList is not None:
            self.softwareList.export(outfile, level, namespace_, name_='softwareList', pretty_print=pretty_print)
        if self.instrumentConfigurationList is not None:
            self.instrumentConfigurationList.export(outfile, level, namespace_, name_='instrumentConfigurationList', pretty_print=pretty_print)
        if self.dataProcessingList is not None:
            self.dataProcessingList.export(outfile, level, namespace_, name_='dataProcessingList', pretty_print=pretty_print)
        if self.sampleList is not None:
            self.sampleList.export(outfile, level, namespace_, name_='sampleList', pretty_print=pretty_print)
        if self.acquisition is not None:
            self.acquisition.export(outfile, level, namespace_, name_='acquisition', pretty_print=pretty_print)
        if self.spectrumList is not None:
            self.spectrumList.export(outfile, level, namespace_, name_='spectrumList', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='nmrMLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.accession_url is not None and 'accession_url' not in already_processed:
            already_processed.add('accession_url')
            showIndent(outfile, level)
            outfile.write('accession_url="%s",\n' % (self.accession_url,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cvList is not None:
            showIndent(outfile, level)
            outfile.write('cvList=model_.CVListType(\n')
            self.cvList.exportLiteral(outfile, level, name_='cvList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fileDescription is not None:
            showIndent(outfile, level)
            outfile.write('fileDescription=model_.FileDescriptionType(\n')
            self.fileDescription.exportLiteral(outfile, level, name_='fileDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contactList is not None:
            showIndent(outfile, level)
            outfile.write('contactList=model_.ContactListType(\n')
            self.contactList.exportLiteral(outfile, level, name_='contactList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.referenceableParamGroupList is not None:
            showIndent(outfile, level)
            outfile.write('referenceableParamGroupList=model_.ReferenceableParamGroupListType(\n')
            self.referenceableParamGroupList.exportLiteral(outfile, level, name_='referenceableParamGroupList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sourceFileList is not None:
            showIndent(outfile, level)
            outfile.write('sourceFileList=model_.SourceFileListType(\n')
            self.sourceFileList.exportLiteral(outfile, level, name_='sourceFileList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.softwareList is not None:
            showIndent(outfile, level)
            outfile.write('softwareList=model_.SoftwareListType(\n')
            self.softwareList.exportLiteral(outfile, level, name_='softwareList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.instrumentConfigurationList is not None:
            showIndent(outfile, level)
            outfile.write('instrumentConfigurationList=model_.InstrumentConfigurationListType(\n')
            self.instrumentConfigurationList.exportLiteral(outfile, level, name_='instrumentConfigurationList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataProcessingList is not None:
            showIndent(outfile, level)
            outfile.write('dataProcessingList=model_.DataProcessingListType(\n')
            self.dataProcessingList.exportLiteral(outfile, level, name_='dataProcessingList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sampleList is not None:
            showIndent(outfile, level)
            outfile.write('sampleList=model_.SampleListType(\n')
            self.sampleList.exportLiteral(outfile, level, name_='sampleList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.acquisition is not None:
            showIndent(outfile, level)
            outfile.write('acquisition=model_.AcquisitionType(\n')
            self.acquisition.exportLiteral(outfile, level, name_='acquisition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spectrumList is not None:
            showIndent(outfile, level)
            outfile.write('spectrumList=model_.SpectrumListType(\n')
            self.spectrumList.exportLiteral(outfile, level, name_='spectrumList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('accession_url', node)
        if value is not None and 'accession_url' not in already_processed:
            already_processed.add('accession_url')
            self.accession_url = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cvList':
            obj_ = CVListType.factory()
            obj_.build(child_)
            self.cvList = obj_
        elif nodeName_ == 'fileDescription':
            obj_ = FileDescriptionType.factory()
            obj_.build(child_)
            self.fileDescription = obj_
        elif nodeName_ == 'contactList':
            obj_ = ContactListType.factory()
            obj_.build(child_)
            self.contactList = obj_
        elif nodeName_ == 'referenceableParamGroupList':
            obj_ = ReferenceableParamGroupListType.factory()
            obj_.build(child_)
            self.referenceableParamGroupList = obj_
        elif nodeName_ == 'sourceFileList':
            obj_ = SourceFileListType.factory()
            obj_.build(child_)
            self.sourceFileList = obj_
        elif nodeName_ == 'softwareList':
            obj_ = SoftwareListType.factory()
            obj_.build(child_)
            self.softwareList = obj_
        elif nodeName_ == 'instrumentConfigurationList':
            obj_ = InstrumentConfigurationListType.factory()
            obj_.build(child_)
            self.instrumentConfigurationList = obj_
        elif nodeName_ == 'dataProcessingList':
            obj_ = DataProcessingListType.factory()
            obj_.build(child_)
            self.dataProcessingList = obj_
        elif nodeName_ == 'sampleList':
            obj_ = SampleListType.factory()
            obj_.build(child_)
            self.sampleList = obj_
        elif nodeName_ == 'acquisition':
            obj_ = AcquisitionType.factory()
            obj_.build(child_)
            self.acquisition = obj_
        elif nodeName_ == 'spectrumList':
            obj_ = SpectrumListType.factory()
            obj_.build(child_)
            self.spectrumList = obj_
# end class nmrMLType


class CVListType(GeneratedsSuper):
    """Container for one or more controlled vocabulary definitions.The
    number of CV definitions in this nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, count=None, cv=None):
        self.count = _cast(int, count)
        if cv is None:
            self.cv = []
        else:
            self.cv = cv
    def factory(*args_, **kwargs_):
        if CVListType.subclass:
            return CVListType.subclass(*args_, **kwargs_)
        else:
            return CVListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cv(self): return self.cv
    def set_cv(self, cv): self.cv = cv
    def add_cv(self, value): self.cv.append(value)
    def insert_cv(self, index, value): self.cv[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.cv
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='CVListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='CVListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='CVListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cv_ in self.cv:
            cv_.export(outfile, level, namespace_, name_='cv', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CVListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cv=[\n')
        level += 1
        for cv_ in self.cv:
            showIndent(outfile, level)
            outfile.write('model_.CVType(\n')
            cv_.exportLiteral(outfile, level, name_='CVType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cv':
            obj_ = CVType.factory()
            obj_.build(child_)
            self.cv.append(obj_)
# end class CVListType


class CVType(GeneratedsSuper):
    """Information about an ontology or CV source and a short 'lookup' tag
    to refer to.The short label to be used as a reference tag with
    which to refer to this particular Controlled Vocabulary source
    description (e.g., from the cvLabel attribute, in CVParamType
    elements).The usual name for the resource (e.g. The MSI-NMR
    Controlled Vocabulary).The version of the CV from which the
    referred-to terms are drawn.The URI for the resource."""
    subclass = None
    superclass = None
    def __init__(self, fullName=None, version=None, id=None, URI=None):
        self.fullName = _cast(None, fullName)
        self.version = _cast(None, version)
        self.id = _cast(None, id)
        self.URI = _cast(None, URI)
        pass
    def factory(*args_, **kwargs_):
        if CVType.subclass:
            return CVType.subclass(*args_, **kwargs_)
        else:
            return CVType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='CVType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='CVType'):
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            outfile.write(' fullName=%s' % (self.gds_format_string(quote_attrib(self.fullName).encode(ExternalEncoding), input_name='fullName'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (self.gds_format_string(quote_attrib(self.URI).encode(ExternalEncoding), input_name='URI'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='CVType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CVType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            showIndent(outfile, level)
            outfile.write('fullName="%s",\n' % (self.fullName,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            showIndent(outfile, level)
            outfile.write('URI="%s",\n' % (self.URI,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fullName', node)
        if value is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            self.fullName = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CVType


class ContactListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, contact=None):
        if contact is None:
            self.contact = []
        else:
            self.contact = contact
    def factory(*args_, **kwargs_):
        if ContactListType.subclass:
            return ContactListType.subclass(*args_, **kwargs_)
        else:
            return ContactListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contact(self): return self.contact
    def set_contact(self, contact): self.contact = contact
    def add_contact(self, value): self.contact.append(value)
    def insert_contact(self, index, value): self.contact[index] = value
    def hasContent_(self):
        if (
            self.contact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ContactListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ContactListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ContactListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for contact_ in self.contact:
            contact_.export(outfile, level, namespace_, name_='contact', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ContactListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('contact=[\n')
        level += 1
        for contact_ in self.contact:
            showIndent(outfile, level)
            outfile.write('model_.ContactType(\n')
            contact_.exportLiteral(outfile, level, name_='ContactType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.contact.append(obj_)
# end class ContactListType


class ContactRefType(GeneratedsSuper):
    """This attribute must reference the 'id' of the contact node in the
    contactList."""
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if ContactRefType.subclass:
            return ContactRefType.subclass(*args_, **kwargs_)
        else:
            return ContactRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ContactRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ContactRefType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ContactRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ContactRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContactRefType


class ContactRefListType(GeneratedsSuper):
    """This number of source files referenced in this list."""
    subclass = None
    superclass = None
    def __init__(self, count=None, contactRef=None):
        self.count = _cast(int, count)
        if contactRef is None:
            self.contactRef = []
        else:
            self.contactRef = contactRef
    def factory(*args_, **kwargs_):
        if ContactRefListType.subclass:
            return ContactRefListType.subclass(*args_, **kwargs_)
        else:
            return ContactRefListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contactRef(self): return self.contactRef
    def set_contactRef(self, contactRef): self.contactRef = contactRef
    def add_contactRef(self, value): self.contactRef.append(value)
    def insert_contactRef(self, index, value): self.contactRef[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.contactRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ContactRefListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactRefListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ContactRefListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ContactRefListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for contactRef_ in self.contactRef:
            contactRef_.export(outfile, level, namespace_, name_='contactRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ContactRefListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('contactRef=[\n')
        level += 1
        for contactRef_ in self.contactRef:
            showIndent(outfile, level)
            outfile.write('model_.ContactRefType(\n')
            contactRef_.exportLiteral(outfile, level, name_='ContactRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contactRef':
            obj_ = ContactRefType.factory()
            obj_.build(child_)
            self.contactRef.append(obj_)
# end class ContactRefListType


class FileDescriptionType(GeneratedsSuper):
    """Information pertaining to the entire nmrML file (i.e. not specific
    to any part of the data set) is stored here. The
    FileDescriptionType element is intended to contain a summary
    description of the current nmrML file, for example it could say
    that the file has a 1D FID, a processed spectra, and a peak
    picked spectra. It does not point to source files or anything
    like that. It is intended to make it easy to determine what is
    inside a file without having to look for different element types
    etc and build a summary yourself. RawSpectrumFile would not be a
    good name. nmrMLInstanceSummary might be a more intuitive name."""
    subclass = None
    superclass = None
    def __init__(self, fileContent=None):
        self.fileContent = fileContent
    def factory(*args_, **kwargs_):
        if FileDescriptionType.subclass:
            return FileDescriptionType.subclass(*args_, **kwargs_)
        else:
            return FileDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileContent(self): return self.fileContent
    def set_fileContent(self, fileContent): self.fileContent = fileContent
    def hasContent_(self):
        if (
            self.fileContent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='FileDescriptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='FileDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='FileDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fileContent is not None:
            self.fileContent.export(outfile, level, namespace_, name_='fileContent', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileDescriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fileContent is not None:
            showIndent(outfile, level)
            outfile.write('fileContent=model_.ParamGroupType(\n')
            self.fileContent.exportLiteral(outfile, level, name_='fileContent')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileContent':
            class_obj_ = self.get_class_obj_(child_, ParamGroupType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.fileContent = obj_
# end class FileDescriptionType


class CVTermType(GeneratedsSuper):
    """This element holds additional data or annotation as a simple CV term
    with no further values (Parameters) associated with it. Only
    controlled CV terms values are allowed here.A reference to the
    CV 'id' attribute as defined in the cvList in this nmrML
    file.The accession number of the referred-to term in the named
    resource (e.g.: NMR:000012).The actual name for the parameter,
    from the referred-to controlled vocabulary. This should be the
    preferred name associated with the specified accession number."""
    subclass = None
    superclass = None
    def __init__(self, cvRef=None, accession=None, name=None, extensiontype_=None):
        self.cvRef = _cast(None, cvRef)
        self.accession = _cast(None, accession)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CVTermType.subclass:
            return CVTermType.subclass(*args_, **kwargs_)
        else:
            return CVTermType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cvRef(self): return self.cvRef
    def set_cvRef(self, cvRef): self.cvRef = cvRef
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='CVTermType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVTermType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='CVTermType'):
        if self.cvRef is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            outfile.write(' cvRef=%s' % (self.gds_format_string(quote_attrib(self.cvRef).encode(ExternalEncoding), input_name='cvRef'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='dx:', name_='CVTermType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CVTermType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cvRef is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            showIndent(outfile, level)
            outfile.write('cvRef="%s",\n' % (self.cvRef,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cvRef', node)
        if value is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            self.cvRef = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CVTermType


class CVParamType(GeneratedsSuper):
    """This element holds additional data or annotation. In contrast to
    CVTermType, here a pair of CV term plus a value (=Parameter) is
    captured. Only controlled values are allowed here.A reference to
    the CV 'id' attribute as defined in the cvList in this nmrML
    file.The accession number of the referred-to term in the named
    resource (e.g.: NMR:000012).The actual name for the parameter,
    from the referred-to controlled vocabulary. This should be the
    preferred name associated with the specified accession
    number.The value for the parameter; may be absent if not
    appropriate, or a numeric or symbolic value, or may itself be CV
    (legal values for a parameter should be enumerated and defined
    in the ontology)."""
    subclass = None
    superclass = None
    def __init__(self, cvRef=None, accession=None, value=None, name=None):
        self.cvRef = _cast(None, cvRef)
        self.accession = _cast(None, accession)
        self.value = _cast(None, value)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if CVParamType.subclass:
            return CVParamType.subclass(*args_, **kwargs_)
        else:
            return CVParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cvRef(self): return self.cvRef
    def set_cvRef(self, cvRef): self.cvRef = cvRef
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='CVParamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='CVParamType'):
        if self.cvRef is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            outfile.write(' cvRef=%s' % (self.gds_format_string(quote_attrib(self.cvRef).encode(ExternalEncoding), input_name='cvRef'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='CVParamType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CVParamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cvRef is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            showIndent(outfile, level)
            outfile.write('cvRef="%s",\n' % (self.cvRef,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cvRef', node)
        if value is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            self.cvRef = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CVParamType


class CVParamWithUnitType(GeneratedsSuper):
    """This element holds additional data or annotation. Only controlled
    values are allowed here.A reference to the CV 'id' attribute as
    defined in the cvList in this nmrML file.The accession number of
    the referred-to term in the named resource (e.g.:
    NMR:000012).The actual name for the parameter, from the
    referred-to controlled vocabulary. This should be the preferred
    name associated with the specified accession number.The value
    for the parameter; may be absent if not appropriate, or a
    numeric or symbolic value, or may itself be CV (legal values for
    a parameter should be enumerated and defined in the ontology).If
    a unit term is referenced, this attribute must refer to the CV
    'id' attribute defined in the cvList in this nmrML file.An
    optional CV accession number for the unit term associated with
    the value, if any (e.g., 'UO:0000266' for 'electron volt').An
    optional CV name for the unit accession number, if any (e.g.,
    'electron volt' for 'UO:0000266' )."""
    subclass = None
    superclass = None
    def __init__(self, name=None, unitName=None, accession=None, value=None, unitAccession=None, cvRef=None, unitCvRef=None):
        self.name = _cast(None, name)
        self.unitName = _cast(None, unitName)
        self.accession = _cast(None, accession)
        self.value = _cast(None, value)
        self.unitAccession = _cast(None, unitAccession)
        self.cvRef = _cast(None, cvRef)
        self.unitCvRef = _cast(None, unitCvRef)
        pass
    def factory(*args_, **kwargs_):
        if CVParamWithUnitType.subclass:
            return CVParamWithUnitType.subclass(*args_, **kwargs_)
        else:
            return CVParamWithUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_unitName(self): return self.unitName
    def set_unitName(self, unitName): self.unitName = unitName
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unitAccession(self): return self.unitAccession
    def set_unitAccession(self, unitAccession): self.unitAccession = unitAccession
    def get_cvRef(self): return self.cvRef
    def set_cvRef(self, cvRef): self.cvRef = cvRef
    def get_unitCvRef(self): return self.unitCvRef
    def set_unitCvRef(self, unitCvRef): self.unitCvRef = unitCvRef
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='CVParamWithUnitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVParamWithUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='CVParamWithUnitType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            outfile.write(' unitName=%s' % (self.gds_format_string(quote_attrib(self.unitName).encode(ExternalEncoding), input_name='unitName'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            outfile.write(' unitAccession=%s' % (self.gds_format_string(quote_attrib(self.unitAccession).encode(ExternalEncoding), input_name='unitAccession'), ))
        if self.cvRef is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            outfile.write(' cvRef=%s' % (self.gds_format_string(quote_attrib(self.cvRef).encode(ExternalEncoding), input_name='cvRef'), ))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            outfile.write(' unitCvRef=%s' % (self.gds_format_string(quote_attrib(self.unitCvRef).encode(ExternalEncoding), input_name='unitCvRef'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='CVParamWithUnitType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CVParamWithUnitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            showIndent(outfile, level)
            outfile.write('unitName="%s",\n' % (self.unitName,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            showIndent(outfile, level)
            outfile.write('unitAccession="%s",\n' % (self.unitAccession,))
        if self.cvRef is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            showIndent(outfile, level)
            outfile.write('cvRef="%s",\n' % (self.cvRef,))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            showIndent(outfile, level)
            outfile.write('unitCvRef="%s",\n' % (self.unitCvRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('unitName', node)
        if value is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            self.unitName = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('unitAccession', node)
        if value is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            self.unitAccession = value
        value = find_attr_value_('cvRef', node)
        if value is not None and 'cvRef' not in already_processed:
            already_processed.add('cvRef')
            self.cvRef = value
        value = find_attr_value_('unitCvRef', node)
        if value is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            self.unitCvRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CVParamWithUnitType


class ValueWithUnitType(GeneratedsSuper):
    """This element holds additional data or annotation. Only controlled
    values are allowed here.An optional CV accession number for the
    unit term associated with the value, if any (e.g., 'UO:0000266'
    for 'electron volt').An optional CV name for the unit accession
    number, if any (e.g., 'electron volt' for 'UO:0000266' ).If a
    unit term is referenced, this attribute must refer to the CV
    'id' attribute defined in the cvList in this nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, unitName=None, unitCvRef=None, value=None, unitAccession=None):
        self.unitName = _cast(None, unitName)
        self.unitCvRef = _cast(None, unitCvRef)
        self.value = _cast(None, value)
        self.unitAccession = _cast(None, unitAccession)
        pass
    def factory(*args_, **kwargs_):
        if ValueWithUnitType.subclass:
            return ValueWithUnitType.subclass(*args_, **kwargs_)
        else:
            return ValueWithUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitName(self): return self.unitName
    def set_unitName(self, unitName): self.unitName = unitName
    def get_unitCvRef(self): return self.unitCvRef
    def set_unitCvRef(self, unitCvRef): self.unitCvRef = unitCvRef
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unitAccession(self): return self.unitAccession
    def set_unitAccession(self, unitAccession): self.unitAccession = unitAccession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ValueWithUnitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueWithUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ValueWithUnitType'):
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            outfile.write(' unitName=%s' % (self.gds_format_string(quote_attrib(self.unitName).encode(ExternalEncoding), input_name='unitName'), ))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            outfile.write(' unitCvRef=%s' % (self.gds_format_string(quote_attrib(self.unitCvRef).encode(ExternalEncoding), input_name='unitCvRef'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            outfile.write(' unitAccession=%s' % (self.gds_format_string(quote_attrib(self.unitAccession).encode(ExternalEncoding), input_name='unitAccession'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ValueWithUnitType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ValueWithUnitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            showIndent(outfile, level)
            outfile.write('unitName="%s",\n' % (self.unitName,))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            showIndent(outfile, level)
            outfile.write('unitCvRef="%s",\n' % (self.unitCvRef,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            showIndent(outfile, level)
            outfile.write('unitAccession="%s",\n' % (self.unitAccession,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitName', node)
        if value is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            self.unitName = value
        value = find_attr_value_('unitCvRef', node)
        if value is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            self.unitCvRef = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('unitAccession', node)
        if value is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            self.unitAccession = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ValueWithUnitType


class UserParamType(GeneratedsSuper):
    """Uncontrolled user parameters (essentially allowing free text).
    Before using these, one should verify whether there is an
    appropriate CV term available, and if so, use the CV term
    insteadThe name for the parameter.The datatype of the parameter,
    where appropriate (e.g.: xsd:float).The value for the parameter,
    where appropriate.An optional CV accession number for the unit
    term associated with the value, if any (e.g., 'UO:0000266' for
    'electron volt').An optional CV name for the unit accession
    number, if any (e.g., 'electron volt' for 'UO:0000266' ).If a
    unit term is referenced, this attribute must refer to the CV
    'id' attribute defined in the cvList in this nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, name=None, unitName=None, valueType=None, value=None, unitAccession=None, unitCvRef=None):
        self.name = _cast(None, name)
        self.unitName = _cast(None, unitName)
        self.valueType = _cast(None, valueType)
        self.value = _cast(None, value)
        self.unitAccession = _cast(None, unitAccession)
        self.unitCvRef = _cast(None, unitCvRef)
        pass
    def factory(*args_, **kwargs_):
        if UserParamType.subclass:
            return UserParamType.subclass(*args_, **kwargs_)
        else:
            return UserParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_unitName(self): return self.unitName
    def set_unitName(self, unitName): self.unitName = unitName
    def get_valueType(self): return self.valueType
    def set_valueType(self, valueType): self.valueType = valueType
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unitAccession(self): return self.unitAccession
    def set_unitAccession(self, unitAccession): self.unitAccession = unitAccession
    def get_unitCvRef(self): return self.unitCvRef
    def set_unitCvRef(self, unitCvRef): self.unitCvRef = unitCvRef
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='UserParamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='UserParamType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            outfile.write(' unitName=%s' % (self.gds_format_string(quote_attrib(self.unitName).encode(ExternalEncoding), input_name='unitName'), ))
        if self.valueType is not None and 'valueType' not in already_processed:
            already_processed.add('valueType')
            outfile.write(' valueType=%s' % (self.gds_format_string(quote_attrib(self.valueType).encode(ExternalEncoding), input_name='valueType'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            outfile.write(' unitAccession=%s' % (self.gds_format_string(quote_attrib(self.unitAccession).encode(ExternalEncoding), input_name='unitAccession'), ))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            outfile.write(' unitCvRef=%s' % (self.gds_format_string(quote_attrib(self.unitCvRef).encode(ExternalEncoding), input_name='unitCvRef'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='UserParamType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='UserParamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            showIndent(outfile, level)
            outfile.write('unitName="%s",\n' % (self.unitName,))
        if self.valueType is not None and 'valueType' not in already_processed:
            already_processed.add('valueType')
            showIndent(outfile, level)
            outfile.write('valueType="%s",\n' % (self.valueType,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            showIndent(outfile, level)
            outfile.write('unitAccession="%s",\n' % (self.unitAccession,))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            showIndent(outfile, level)
            outfile.write('unitCvRef="%s",\n' % (self.unitCvRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('unitName', node)
        if value is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            self.unitName = value
        value = find_attr_value_('valueType', node)
        if value is not None and 'valueType' not in already_processed:
            already_processed.add('valueType')
            self.valueType = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('unitAccession', node)
        if value is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            self.unitAccession = value
        value = find_attr_value_('unitCvRef', node)
        if value is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            self.unitCvRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UserParamType


class ParamGroupType(GeneratedsSuper):
    """Structure allowing the use of a controlled (cvParam) or uncontrolled
    vocabulary (userParam), or a reference to a predefined set of
    these in this nmrML file (paramGroupRef)."""
    subclass = None
    superclass = None
    def __init__(self, referenceableParamGroupRef=None, cvParam=None, cvParamWithUnit=None, cvTerm=None, userParam=None, extensiontype_=None):
        if referenceableParamGroupRef is None:
            self.referenceableParamGroupRef = []
        else:
            self.referenceableParamGroupRef = referenceableParamGroupRef
        if cvParam is None:
            self.cvParam = []
        else:
            self.cvParam = cvParam
        if cvParamWithUnit is None:
            self.cvParamWithUnit = []
        else:
            self.cvParamWithUnit = cvParamWithUnit
        if cvTerm is None:
            self.cvTerm = []
        else:
            self.cvTerm = cvTerm
        if userParam is None:
            self.userParam = []
        else:
            self.userParam = userParam
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ParamGroupType.subclass:
            return ParamGroupType.subclass(*args_, **kwargs_)
        else:
            return ParamGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceableParamGroupRef(self): return self.referenceableParamGroupRef
    def set_referenceableParamGroupRef(self, referenceableParamGroupRef): self.referenceableParamGroupRef = referenceableParamGroupRef
    def add_referenceableParamGroupRef(self, value): self.referenceableParamGroupRef.append(value)
    def insert_referenceableParamGroupRef(self, index, value): self.referenceableParamGroupRef[index] = value
    def get_cvParam(self): return self.cvParam
    def set_cvParam(self, cvParam): self.cvParam = cvParam
    def add_cvParam(self, value): self.cvParam.append(value)
    def insert_cvParam(self, index, value): self.cvParam[index] = value
    def get_cvParamWithUnit(self): return self.cvParamWithUnit
    def set_cvParamWithUnit(self, cvParamWithUnit): self.cvParamWithUnit = cvParamWithUnit
    def add_cvParamWithUnit(self, value): self.cvParamWithUnit.append(value)
    def insert_cvParamWithUnit(self, index, value): self.cvParamWithUnit[index] = value
    def get_cvTerm(self): return self.cvTerm
    def set_cvTerm(self, cvTerm): self.cvTerm = cvTerm
    def add_cvTerm(self, value): self.cvTerm.append(value)
    def insert_cvTerm(self, index, value): self.cvTerm[index] = value
    def get_userParam(self): return self.userParam
    def set_userParam(self, userParam): self.userParam = userParam
    def add_userParam(self, value): self.userParam.append(value)
    def insert_userParam(self, index, value): self.userParam[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.referenceableParamGroupRef or
            self.cvParam or
            self.cvParamWithUnit or
            self.cvTerm or
            self.userParam
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ParamGroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParamGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ParamGroupType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ParamGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referenceableParamGroupRef_ in self.referenceableParamGroupRef:
            referenceableParamGroupRef_.export(outfile, level, namespace_, name_='referenceableParamGroupRef', pretty_print=pretty_print)
        for cvParam_ in self.cvParam:
            cvParam_.export(outfile, level, namespace_, name_='cvParam', pretty_print=pretty_print)
        for cvParamWithUnit_ in self.cvParamWithUnit:
            cvParamWithUnit_.export(outfile, level, namespace_, name_='cvParamWithUnit', pretty_print=pretty_print)
        for cvTerm_ in self.cvTerm:
            cvTerm_.export(outfile, level, namespace_, name_='cvTerm', pretty_print=pretty_print)
        for userParam_ in self.userParam:
            userParam_.export(outfile, level, namespace_, name_='userParam', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ParamGroupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('referenceableParamGroupRef=[\n')
        level += 1
        for referenceableParamGroupRef_ in self.referenceableParamGroupRef:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceableParamGroupRefType(\n')
            referenceableParamGroupRef_.exportLiteral(outfile, level, name_='ReferenceableParamGroupRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cvParam=[\n')
        level += 1
        for cvParam_ in self.cvParam:
            showIndent(outfile, level)
            outfile.write('model_.CVParamType(\n')
            cvParam_.exportLiteral(outfile, level, name_='CVParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cvParamWithUnit=[\n')
        level += 1
        for cvParamWithUnit_ in self.cvParamWithUnit:
            showIndent(outfile, level)
            outfile.write('model_.CVParamWithUnitType(\n')
            cvParamWithUnit_.exportLiteral(outfile, level, name_='CVParamWithUnitType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cvTerm=[\n')
        level += 1
        for cvTerm_ in self.cvTerm:
            showIndent(outfile, level)
            outfile.write('model_.CVTermType(\n')
            cvTerm_.exportLiteral(outfile, level, name_='CVTermType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('userParam=[\n')
        level += 1
        for userParam_ in self.userParam:
            showIndent(outfile, level)
            outfile.write('model_.UserParamType(\n')
            userParam_.exportLiteral(outfile, level, name_='UserParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceableParamGroupRef':
            obj_ = ReferenceableParamGroupRefType.factory()
            obj_.build(child_)
            self.referenceableParamGroupRef.append(obj_)
        elif nodeName_ == 'cvParam':
            obj_ = CVParamType.factory()
            obj_.build(child_)
            self.cvParam.append(obj_)
        elif nodeName_ == 'cvParamWithUnit':
            obj_ = CVParamWithUnitType.factory()
            obj_.build(child_)
            self.cvParamWithUnit.append(obj_)
        elif nodeName_ == 'cvTerm':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.cvTerm.append(obj_)
        elif nodeName_ == 'userParam':
            obj_ = UserParamType.factory()
            obj_.build(child_)
            self.userParam.append(obj_)
# end class ParamGroupType


class ReferenceableParamGroupType(GeneratedsSuper):
    """A collection of CVParam and UserParam elements that can be
    referenced from elsewhere in this nmrML document by using the
    'paramGroupRef' element in that location to reference the 'id'
    attribute value of this element.The identifier with which to
    reference this ReferenceableParamGroup."""
    subclass = None
    superclass = None
    def __init__(self, id=None, cvParam=None, userParam=None):
        self.id = _cast(None, id)
        if cvParam is None:
            self.cvParam = []
        else:
            self.cvParam = cvParam
        if userParam is None:
            self.userParam = []
        else:
            self.userParam = userParam
    def factory(*args_, **kwargs_):
        if ReferenceableParamGroupType.subclass:
            return ReferenceableParamGroupType.subclass(*args_, **kwargs_)
        else:
            return ReferenceableParamGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cvParam(self): return self.cvParam
    def set_cvParam(self, cvParam): self.cvParam = cvParam
    def add_cvParam(self, value): self.cvParam.append(value)
    def insert_cvParam(self, index, value): self.cvParam[index] = value
    def get_userParam(self): return self.userParam
    def set_userParam(self, userParam): self.userParam = userParam
    def add_userParam(self, value): self.userParam.append(value)
    def insert_userParam(self, index, value): self.userParam[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.cvParam or
            self.userParam
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ReferenceableParamGroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceableParamGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ReferenceableParamGroupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ReferenceableParamGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cvParam_ in self.cvParam:
            cvParam_.export(outfile, level, namespace_, name_='cvParam', pretty_print=pretty_print)
        for userParam_ in self.userParam:
            userParam_.export(outfile, level, namespace_, name_='userParam', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceableParamGroupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cvParam=[\n')
        level += 1
        for cvParam_ in self.cvParam:
            showIndent(outfile, level)
            outfile.write('model_.CVParamType(\n')
            cvParam_.exportLiteral(outfile, level, name_='CVParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('userParam=[\n')
        level += 1
        for userParam_ in self.userParam:
            showIndent(outfile, level)
            outfile.write('model_.UserParamType(\n')
            userParam_.exportLiteral(outfile, level, name_='UserParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cvParam':
            obj_ = CVParamType.factory()
            obj_.build(child_)
            self.cvParam.append(obj_)
        elif nodeName_ == 'userParam':
            obj_ = UserParamType.factory()
            obj_.build(child_)
            self.userParam.append(obj_)
# end class ReferenceableParamGroupType


class ReferenceableParamGroupRefType(GeneratedsSuper):
    """A reference to a previously defined ParamGroup, which is a reusable
    container of one or more cvParams.Reference to the id attribute
    in a referenceableParamGroup."""
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if ReferenceableParamGroupRefType.subclass:
            return ReferenceableParamGroupRefType.subclass(*args_, **kwargs_)
        else:
            return ReferenceableParamGroupRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ReferenceableParamGroupRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceableParamGroupRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ReferenceableParamGroupRefType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ReferenceableParamGroupRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ReferenceableParamGroupRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceableParamGroupRefType


class ReferenceableParamGroupListType(GeneratedsSuper):
    """Container for a list of referenceableParamGroupsThe number of
    ParamGroups defined in this nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, count=None, referenceableParamGroup=None):
        self.count = _cast(int, count)
        if referenceableParamGroup is None:
            self.referenceableParamGroup = []
        else:
            self.referenceableParamGroup = referenceableParamGroup
    def factory(*args_, **kwargs_):
        if ReferenceableParamGroupListType.subclass:
            return ReferenceableParamGroupListType.subclass(*args_, **kwargs_)
        else:
            return ReferenceableParamGroupListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceableParamGroup(self): return self.referenceableParamGroup
    def set_referenceableParamGroup(self, referenceableParamGroup): self.referenceableParamGroup = referenceableParamGroup
    def add_referenceableParamGroup(self, value): self.referenceableParamGroup.append(value)
    def insert_referenceableParamGroup(self, index, value): self.referenceableParamGroup[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.referenceableParamGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ReferenceableParamGroupListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceableParamGroupListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ReferenceableParamGroupListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ReferenceableParamGroupListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referenceableParamGroup_ in self.referenceableParamGroup:
            referenceableParamGroup_.export(outfile, level, namespace_, name_='referenceableParamGroup', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceableParamGroupListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('referenceableParamGroup=[\n')
        level += 1
        for referenceableParamGroup_ in self.referenceableParamGroup:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceableParamGroupType(\n')
            referenceableParamGroup_.exportLiteral(outfile, level, name_='ReferenceableParamGroupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceableParamGroup':
            obj_ = ReferenceableParamGroupType.factory()
            obj_.build(child_)
            self.referenceableParamGroup.append(obj_)
# end class ReferenceableParamGroupListType


class SourceFileListType(GeneratedsSuper):
    """List and descriptions of the source files this nmrML document was
    generated or derived fromNumber of source files used in
    generating the instance document."""
    subclass = None
    superclass = None
    def __init__(self, count=None, sourceFile=None):
        self.count = _cast(int, count)
        if sourceFile is None:
            self.sourceFile = []
        else:
            self.sourceFile = sourceFile
    def factory(*args_, **kwargs_):
        if SourceFileListType.subclass:
            return SourceFileListType.subclass(*args_, **kwargs_)
        else:
            return SourceFileListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceFile(self): return self.sourceFile
    def set_sourceFile(self, sourceFile): self.sourceFile = sourceFile
    def add_sourceFile(self, value): self.sourceFile.append(value)
    def insert_sourceFile(self, index, value): self.sourceFile[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.sourceFile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SourceFileListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceFileListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SourceFileListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SourceFileListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sourceFile_ in self.sourceFile:
            sourceFile_.export(outfile, level, namespace_, name_='sourceFile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourceFileListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sourceFile=[\n')
        level += 1
        for sourceFile_ in self.sourceFile:
            showIndent(outfile, level)
            outfile.write('model_.SourceFileType(\n')
            sourceFile_.exportLiteral(outfile, level, name_='SourceFileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sourceFile':
            obj_ = SourceFileType.factory()
            obj_.build(child_)
            self.sourceFile.append(obj_)
# end class SourceFileListType


class SampleListType(GeneratedsSuper):
    """List and descriptions of samples.The number of Samples defined in
    this nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, count=None, sample=None):
        self.count = _cast(int, count)
        if sample is None:
            self.sample = []
        else:
            self.sample = sample
    def factory(*args_, **kwargs_):
        if SampleListType.subclass:
            return SampleListType.subclass(*args_, **kwargs_)
        else:
            return SampleListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sample(self): return self.sample
    def set_sample(self, sample): self.sample = sample
    def add_sample(self, value): self.sample.append(value)
    def insert_sample(self, index, value): self.sample[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.sample
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SampleListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SampleListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SampleListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SampleListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sample_ in self.sample:
            sample_.export(outfile, level, namespace_, name_='sample', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SampleListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sample=[\n')
        level += 1
        for sample_ in self.sample:
            showIndent(outfile, level)
            outfile.write('model_.SampleType(\n')
            sample_.exportLiteral(outfile, level, name_='SampleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sample':
            obj_ = SampleType.factory()
            obj_.build(child_)
            self.sample.append(obj_)
# end class SampleListType


class SampleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, originalBiologicalSampleReference=None, originalBiologicalSamplepH=None, postBufferpH=None, buffer=None, fieldFrequencyLock=None, chemicalShiftStandard=None, solventType=None, additionalSoluteList=None, solventConcentration=None, concentrationStandard=None):
        self.originalBiologicalSampleReference = _cast(None, originalBiologicalSampleReference)
        self.originalBiologicalSamplepH = originalBiologicalSamplepH
        self.postBufferpH = postBufferpH
        self.buffer = buffer
        self.fieldFrequencyLock = fieldFrequencyLock
        self.chemicalShiftStandard = chemicalShiftStandard
        self.solventType = solventType
        self.additionalSoluteList = additionalSoluteList
        self.solventConcentration = solventConcentration
        self.concentrationStandard = concentrationStandard
    def factory(*args_, **kwargs_):
        if SampleType.subclass:
            return SampleType.subclass(*args_, **kwargs_)
        else:
            return SampleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalBiologicalSamplepH(self): return self.originalBiologicalSamplepH
    def set_originalBiologicalSamplepH(self, originalBiologicalSamplepH): self.originalBiologicalSamplepH = originalBiologicalSamplepH
    def get_postBufferpH(self): return self.postBufferpH
    def set_postBufferpH(self, postBufferpH): self.postBufferpH = postBufferpH
    def get_buffer(self): return self.buffer
    def set_buffer(self, buffer): self.buffer = buffer
    def get_fieldFrequencyLock(self): return self.fieldFrequencyLock
    def set_fieldFrequencyLock(self, fieldFrequencyLock): self.fieldFrequencyLock = fieldFrequencyLock
    def get_chemicalShiftStandard(self): return self.chemicalShiftStandard
    def set_chemicalShiftStandard(self, chemicalShiftStandard): self.chemicalShiftStandard = chemicalShiftStandard
    def get_solventType(self): return self.solventType
    def set_solventType(self, solventType): self.solventType = solventType
    def get_additionalSoluteList(self): return self.additionalSoluteList
    def set_additionalSoluteList(self, additionalSoluteList): self.additionalSoluteList = additionalSoluteList
    def get_solventConcentration(self): return self.solventConcentration
    def set_solventConcentration(self, solventConcentration): self.solventConcentration = solventConcentration
    def get_concentrationStandard(self): return self.concentrationStandard
    def set_concentrationStandard(self, concentrationStandard): self.concentrationStandard = concentrationStandard
    def get_originalBiologicalSampleReference(self): return self.originalBiologicalSampleReference
    def set_originalBiologicalSampleReference(self, originalBiologicalSampleReference): self.originalBiologicalSampleReference = originalBiologicalSampleReference
    def validate_PhType(self, value):
        # Validate type PhType, a restriction on xs:double.
        pass
    def hasContent_(self):
        if (
            self.originalBiologicalSamplepH is not None or
            self.postBufferpH is not None or
            self.buffer is not None or
            self.fieldFrequencyLock is not None or
            self.chemicalShiftStandard is not None or
            self.solventType is not None or
            self.additionalSoluteList is not None or
            self.solventConcentration is not None or
            self.concentrationStandard is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SampleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SampleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SampleType'):
        if self.originalBiologicalSampleReference is not None and 'originalBiologicalSampleReference' not in already_processed:
            already_processed.add('originalBiologicalSampleReference')
            outfile.write(' originalBiologicalSampleReference=%s' % (self.gds_format_string(quote_attrib(self.originalBiologicalSampleReference).encode(ExternalEncoding), input_name='originalBiologicalSampleReference'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SampleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalBiologicalSamplepH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalBiologicalSamplepH>%s</%soriginalBiologicalSamplepH>%s' % (namespace_, self.gds_format_double(self.originalBiologicalSamplepH, input_name='originalBiologicalSamplepH'), namespace_, eol_))
        if self.postBufferpH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostBufferpH>%s</%spostBufferpH>%s' % (namespace_, self.gds_format_double(self.postBufferpH, input_name='postBufferpH'), namespace_, eol_))
        if self.buffer is not None:
            self.buffer.export(outfile, level, namespace_, name_='buffer', pretty_print=pretty_print)
        if self.fieldFrequencyLock is not None:
            self.fieldFrequencyLock.export(outfile, level, namespace_, name_='fieldFrequencyLock', pretty_print=pretty_print)
        if self.chemicalShiftStandard is not None:
            self.chemicalShiftStandard.export(outfile, level, namespace_, name_='chemicalShiftStandard', pretty_print=pretty_print)
        if self.solventType is not None:
            self.solventType.export(outfile, level, namespace_, name_='solventType', pretty_print=pretty_print)
        if self.additionalSoluteList is not None:
            self.additionalSoluteList.export(outfile, level, namespace_, name_='additionalSoluteList', pretty_print=pretty_print)
        if self.solventConcentration is not None:
            self.solventConcentration.export(outfile, level, namespace_, name_='solventConcentration', pretty_print=pretty_print)
        if self.concentrationStandard is not None:
            self.concentrationStandard.export(outfile, level, namespace_, name_='concentrationStandard', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SampleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.originalBiologicalSampleReference is not None and 'originalBiologicalSampleReference' not in already_processed:
            already_processed.add('originalBiologicalSampleReference')
            showIndent(outfile, level)
            outfile.write('originalBiologicalSampleReference="%s",\n' % (self.originalBiologicalSampleReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.originalBiologicalSamplepH is not None:
            showIndent(outfile, level)
            outfile.write('originalBiologicalSamplepH=%e,\n' % self.originalBiologicalSamplepH)
        if self.postBufferpH is not None:
            showIndent(outfile, level)
            outfile.write('postBufferpH=%e,\n' % self.postBufferpH)
        if self.buffer is not None:
            showIndent(outfile, level)
            outfile.write('buffer=model_.CVTermType(\n')
            self.buffer.exportLiteral(outfile, level, name_='buffer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fieldFrequencyLock is not None:
            showIndent(outfile, level)
            outfile.write('fieldFrequencyLock=model_.fieldFrequencyLockType(\n')
            self.fieldFrequencyLock.exportLiteral(outfile, level, name_='fieldFrequencyLock')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.chemicalShiftStandard is not None:
            showIndent(outfile, level)
            outfile.write('chemicalShiftStandard=model_.CVParamType(\n')
            self.chemicalShiftStandard.exportLiteral(outfile, level, name_='chemicalShiftStandard')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.solventType is not None:
            showIndent(outfile, level)
            outfile.write('solventType=model_.CVTermType(\n')
            self.solventType.exportLiteral(outfile, level, name_='solventType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.additionalSoluteList is not None:
            showIndent(outfile, level)
            outfile.write('additionalSoluteList=model_.AdditionalSoluteListType(\n')
            self.additionalSoluteList.exportLiteral(outfile, level, name_='additionalSoluteList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.solventConcentration is not None:
            showIndent(outfile, level)
            outfile.write('solventConcentration=model_.ValueWithUnitType(\n')
            self.solventConcentration.exportLiteral(outfile, level, name_='solventConcentration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concentrationStandard is not None:
            showIndent(outfile, level)
            outfile.write('concentrationStandard=model_.concentrationStandardType(\n')
            self.concentrationStandard.exportLiteral(outfile, level, name_='concentrationStandard')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('originalBiologicalSampleReference', node)
        if value is not None and 'originalBiologicalSampleReference' not in already_processed:
            already_processed.add('originalBiologicalSampleReference')
            self.originalBiologicalSampleReference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalBiologicalSamplepH':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'originalBiologicalSamplepH')
            self.originalBiologicalSamplepH = fval_
            self.validate_PhType(self.originalBiologicalSamplepH)    # validate type PhType
        elif nodeName_ == 'postBufferpH':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'postBufferpH')
            self.postBufferpH = fval_
            self.validate_PhType(self.postBufferpH)    # validate type PhType
        elif nodeName_ == 'buffer':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.buffer = obj_
        elif nodeName_ == 'fieldFrequencyLock':
            obj_ = fieldFrequencyLockType.factory()
            obj_.build(child_)
            self.fieldFrequencyLock = obj_
        elif nodeName_ == 'chemicalShiftStandard':
            obj_ = CVParamType.factory()
            obj_.build(child_)
            self.chemicalShiftStandard = obj_
        elif nodeName_ == 'solventType':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.solventType = obj_
        elif nodeName_ == 'additionalSoluteList':
            obj_ = AdditionalSoluteListType.factory()
            obj_.build(child_)
            self.additionalSoluteList = obj_
        elif nodeName_ == 'solventConcentration':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.solventConcentration = obj_
        elif nodeName_ == 'concentrationStandard':
            obj_ = concentrationStandardType.factory()
            obj_.build(child_)
            self.concentrationStandard = obj_
# end class SampleType


class SoftwareListType(GeneratedsSuper):
    """List and descriptions of software used to acquire and/or process the
    data in this nmrML file.The number of softwares defined in this
    nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, count=None, software=None):
        self.count = _cast(int, count)
        if software is None:
            self.software = []
        else:
            self.software = software
    def factory(*args_, **kwargs_):
        if SoftwareListType.subclass:
            return SoftwareListType.subclass(*args_, **kwargs_)
        else:
            return SoftwareListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_software(self): return self.software
    def set_software(self, software): self.software = software
    def add_software(self, value): self.software.append(value)
    def insert_software(self, index, value): self.software[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.software
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SoftwareListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoftwareListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SoftwareListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SoftwareListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for software_ in self.software:
            software_.export(outfile, level, namespace_, name_='software', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SoftwareListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('software=[\n')
        level += 1
        for software_ in self.software:
            showIndent(outfile, level)
            outfile.write('model_.SoftwareType(\n')
            software_.exportLiteral(outfile, level, name_='SoftwareType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'software':
            obj_ = SoftwareType.factory()
            obj_.build(child_)
            self.software.append(obj_)
# end class SoftwareListType


class SoftwareType(CVTermType):
    """Software information.An identifier for this software that is unique
    across all SoftwareTypes.The software version."""
    subclass = None
    superclass = CVTermType
    def __init__(self, cvRef=None, accession=None, name=None, version=None, id=None):
        super(SoftwareType, self).__init__(cvRef, accession, name, )
        self.version = _cast(None, version)
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if SoftwareType.subclass:
            return SoftwareType.subclass(*args_, **kwargs_)
        else:
            return SoftwareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            super(SoftwareType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SoftwareType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoftwareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SoftwareType'):
        super(SoftwareType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SoftwareType')
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SoftwareType', fromsubclass_=False, pretty_print=True):
        super(SoftwareType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SoftwareType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(SoftwareType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SoftwareType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(SoftwareType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SoftwareType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SoftwareType


class SoftwareRefType(GeneratedsSuper):
    """Reference to a previously defined software elementThis attribute
    must be used to reference the 'id' attribute of a software
    element."""
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if SoftwareRefType.subclass:
            return SoftwareRefType.subclass(*args_, **kwargs_)
        else:
            return SoftwareRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SoftwareRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoftwareRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SoftwareRefType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SoftwareRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SoftwareRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SoftwareRefType


class SoftwareRefListType(GeneratedsSuper):
    """This number of source files referenced in this list."""
    subclass = None
    superclass = None
    def __init__(self, count=None, softwareRef=None):
        self.count = _cast(int, count)
        if softwareRef is None:
            self.softwareRef = []
        else:
            self.softwareRef = softwareRef
    def factory(*args_, **kwargs_):
        if SoftwareRefListType.subclass:
            return SoftwareRefListType.subclass(*args_, **kwargs_)
        else:
            return SoftwareRefListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_softwareRef(self): return self.softwareRef
    def set_softwareRef(self, softwareRef): self.softwareRef = softwareRef
    def add_softwareRef(self, value): self.softwareRef.append(value)
    def insert_softwareRef(self, index, value): self.softwareRef[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.softwareRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SoftwareRefListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoftwareRefListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SoftwareRefListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SoftwareRefListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for softwareRef_ in self.softwareRef:
            softwareRef_.export(outfile, level, namespace_, name_='softwareRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SoftwareRefListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('softwareRef=[\n')
        level += 1
        for softwareRef_ in self.softwareRef:
            showIndent(outfile, level)
            outfile.write('model_.SoftwareRefType(\n')
            softwareRef_.exportLiteral(outfile, level, name_='SoftwareRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'softwareRef':
            obj_ = SoftwareRefType.factory()
            obj_.build(child_)
            self.softwareRef.append(obj_)
# end class SoftwareRefListType


class SourceFileType(ParamGroupType):
    """Description of the source file, including location and type. The
    SourceFileType element is intended to be a generic element that
    points to a file that was used to produce the spectrum or the
    nmrML file. It could point to an FID file, a procpar file, a
    pulse program file etc. nmrExperimentSourceFile could be a good
    name but I personally think that SourceFile is an intuitive name
    already.An identifier for this file.Name of the source file,
    without reference to location (either URI or local path).URI-
    formatted location where the file was retrieved."""
    subclass = None
    superclass = ParamGroupType
    def __init__(self, referenceableParamGroupRef=None, cvParam=None, cvParamWithUnit=None, cvTerm=None, userParam=None, sha1=None, location=None, id=None, name=None):
        super(SourceFileType, self).__init__(referenceableParamGroupRef, cvParam, cvParamWithUnit, cvTerm, userParam, )
        self.sha1 = _cast(None, sha1)
        self.location = _cast(None, location)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if SourceFileType.subclass:
            return SourceFileType.subclass(*args_, **kwargs_)
        else:
            return SourceFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sha1(self): return self.sha1
    def set_sha1(self, sha1): self.sha1 = sha1
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(SourceFileType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SourceFileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SourceFileType'):
        super(SourceFileType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SourceFileType')
        if self.sha1 is not None and 'sha1' not in already_processed:
            already_processed.add('sha1')
            outfile.write(' sha1=%s' % (self.gds_format_string(quote_attrib(self.sha1).encode(ExternalEncoding), input_name='sha1'), ))
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_format_string(quote_attrib(self.location).encode(ExternalEncoding), input_name='location'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SourceFileType', fromsubclass_=False, pretty_print=True):
        super(SourceFileType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourceFileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sha1 is not None and 'sha1' not in already_processed:
            already_processed.add('sha1')
            showIndent(outfile, level)
            outfile.write('sha1="%s",\n' % (self.sha1,))
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            showIndent(outfile, level)
            outfile.write('location="%s",\n' % (self.location,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(SourceFileType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SourceFileType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sha1', node)
        if value is not None and 'sha1' not in already_processed:
            already_processed.add('sha1')
            self.sha1 = value
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(SourceFileType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SourceFileType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SourceFileType


class SourceFileRefType(GeneratedsSuper):
    """This attribute must reference the 'id' of the appropriate
    sourceFile."""
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if SourceFileRefType.subclass:
            return SourceFileRefType.subclass(*args_, **kwargs_)
        else:
            return SourceFileRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SourceFileRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceFileRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SourceFileRefType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SourceFileRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SourceFileRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceFileRefType


class SourceFileRefListType(GeneratedsSuper):
    """This number of source files referenced in this list."""
    subclass = None
    superclass = None
    def __init__(self, count=None, sourceFileRef=None):
        self.count = _cast(int, count)
        if sourceFileRef is None:
            self.sourceFileRef = []
        else:
            self.sourceFileRef = sourceFileRef
    def factory(*args_, **kwargs_):
        if SourceFileRefListType.subclass:
            return SourceFileRefListType.subclass(*args_, **kwargs_)
        else:
            return SourceFileRefListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceFileRef(self): return self.sourceFileRef
    def set_sourceFileRef(self, sourceFileRef): self.sourceFileRef = sourceFileRef
    def add_sourceFileRef(self, value): self.sourceFileRef.append(value)
    def insert_sourceFileRef(self, index, value): self.sourceFileRef[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.sourceFileRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SourceFileRefListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceFileRefListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SourceFileRefListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SourceFileRefListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sourceFileRef_ in self.sourceFileRef:
            sourceFileRef_.export(outfile, level, namespace_, name_='sourceFileRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourceFileRefListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sourceFileRef=[\n')
        level += 1
        for sourceFileRef_ in self.sourceFileRef:
            showIndent(outfile, level)
            outfile.write('model_.SourceFileRefType(\n')
            sourceFileRef_.exportLiteral(outfile, level, name_='SourceFileRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sourceFileRef':
            obj_ = SourceFileRefType.factory()
            obj_.build(child_)
            self.sourceFileRef.append(obj_)
# end class SourceFileRefListType


class InstrumentConfigurationType(ParamGroupType):
    """Description of a particular hardware configuration of a NMR
    spectrometer. For software configuration, use a
    ReferenceableParamGroup element.An identifier for this
    instrument configuration."""
    subclass = None
    superclass = ParamGroupType
    def __init__(self, referenceableParamGroupRef=None, cvParam=None, cvParamWithUnit=None, cvTerm=None, userParam=None, id=None, softwareRef=None):
        super(InstrumentConfigurationType, self).__init__(referenceableParamGroupRef, cvParam, cvParamWithUnit, cvTerm, userParam, )
        self.id = _cast(None, id)
        if softwareRef is None:
            self.softwareRef = []
        else:
            self.softwareRef = softwareRef
    def factory(*args_, **kwargs_):
        if InstrumentConfigurationType.subclass:
            return InstrumentConfigurationType.subclass(*args_, **kwargs_)
        else:
            return InstrumentConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_softwareRef(self): return self.softwareRef
    def set_softwareRef(self, softwareRef): self.softwareRef = softwareRef
    def add_softwareRef(self, value): self.softwareRef.append(value)
    def insert_softwareRef(self, index, value): self.softwareRef[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.softwareRef or
            super(InstrumentConfigurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='InstrumentConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='InstrumentConfigurationType'):
        super(InstrumentConfigurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentConfigurationType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='InstrumentConfigurationType', fromsubclass_=False, pretty_print=True):
        super(InstrumentConfigurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for softwareRef_ in self.softwareRef:
            softwareRef_.export(outfile, level, namespace_, name_='softwareRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstrumentConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(InstrumentConfigurationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstrumentConfigurationType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('softwareRef=[\n')
        level += 1
        for softwareRef_ in self.softwareRef:
            showIndent(outfile, level)
            outfile.write('model_.SoftwareRefType(\n')
            softwareRef_.exportLiteral(outfile, level, name_='SoftwareRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(InstrumentConfigurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'softwareRef':
            obj_ = SoftwareRefType.factory()
            obj_.build(child_)
            self.softwareRef.append(obj_)
        super(InstrumentConfigurationType, self).buildChildren(child_, node, nodeName_, True)
# end class InstrumentConfigurationType


class InstrumentConfigurationListType(GeneratedsSuper):
    """List and descriptions of instrument configurations. At least one
    instrument configuration must be specified, even if it is only
    to specify that the instrument is unknown. In that case, the
    "instrument model" term is used to indicate the unknown
    instrument in the instrumentConfiguration.The number of
    instrument configurations present in this list."""
    subclass = None
    superclass = None
    def __init__(self, count=None, instrumentConfiguration=None):
        self.count = _cast(int, count)
        if instrumentConfiguration is None:
            self.instrumentConfiguration = []
        else:
            self.instrumentConfiguration = instrumentConfiguration
    def factory(*args_, **kwargs_):
        if InstrumentConfigurationListType.subclass:
            return InstrumentConfigurationListType.subclass(*args_, **kwargs_)
        else:
            return InstrumentConfigurationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentConfiguration(self): return self.instrumentConfiguration
    def set_instrumentConfiguration(self, instrumentConfiguration): self.instrumentConfiguration = instrumentConfiguration
    def add_instrumentConfiguration(self, value): self.instrumentConfiguration.append(value)
    def insert_instrumentConfiguration(self, index, value): self.instrumentConfiguration[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.instrumentConfiguration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='InstrumentConfigurationListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentConfigurationListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='InstrumentConfigurationListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='InstrumentConfigurationListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrumentConfiguration_ in self.instrumentConfiguration:
            instrumentConfiguration_.export(outfile, level, namespace_, name_='instrumentConfiguration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstrumentConfigurationListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('instrumentConfiguration=[\n')
        level += 1
        for instrumentConfiguration_ in self.instrumentConfiguration:
            showIndent(outfile, level)
            outfile.write('model_.InstrumentConfigurationType(\n')
            instrumentConfiguration_.exportLiteral(outfile, level, name_='InstrumentConfigurationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrumentConfiguration':
            obj_ = InstrumentConfigurationType.factory()
            obj_.build(child_)
            self.instrumentConfiguration.append(obj_)
# end class InstrumentConfigurationListType


class DataProcessingType(GeneratedsSuper):
    """Description of the way in which a particular software was used.A
    unique identifier for this data processing that is unique across
    all DataProcessingTypes."""
    subclass = None
    superclass = None
    def __init__(self, id=None, processingMethod=None):
        self.id = _cast(None, id)
        if processingMethod is None:
            self.processingMethod = []
        else:
            self.processingMethod = processingMethod
    def factory(*args_, **kwargs_):
        if DataProcessingType.subclass:
            return DataProcessingType.subclass(*args_, **kwargs_)
        else:
            return DataProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processingMethod(self): return self.processingMethod
    def set_processingMethod(self, processingMethod): self.processingMethod = processingMethod
    def add_processingMethod(self, value): self.processingMethod.append(value)
    def insert_processingMethod(self, index, value): self.processingMethod[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.processingMethod
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='DataProcessingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='DataProcessingType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='DataProcessingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for processingMethod_ in self.processingMethod:
            processingMethod_.export(outfile, level, namespace_, name_='processingMethod', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataProcessingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('processingMethod=[\n')
        level += 1
        for processingMethod_ in self.processingMethod:
            showIndent(outfile, level)
            outfile.write('model_.ProcessingMethodType(\n')
            processingMethod_.exportLiteral(outfile, level, name_='ProcessingMethodType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processingMethod':
            obj_ = ProcessingMethodType.factory()
            obj_.build(child_)
            self.processingMethod.append(obj_)
# end class DataProcessingType


class DataProcessingListType(GeneratedsSuper):
    """List and descriptions of data processing applied to this data.The
    number of DataProcessingTypes in this nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, count=None, dataProcessing=None):
        self.count = _cast(int, count)
        if dataProcessing is None:
            self.dataProcessing = []
        else:
            self.dataProcessing = dataProcessing
    def factory(*args_, **kwargs_):
        if DataProcessingListType.subclass:
            return DataProcessingListType.subclass(*args_, **kwargs_)
        else:
            return DataProcessingListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataProcessing(self): return self.dataProcessing
    def set_dataProcessing(self, dataProcessing): self.dataProcessing = dataProcessing
    def add_dataProcessing(self, value): self.dataProcessing.append(value)
    def insert_dataProcessing(self, index, value): self.dataProcessing[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.dataProcessing
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='DataProcessingListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataProcessingListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='DataProcessingListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='DataProcessingListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataProcessing_ in self.dataProcessing:
            dataProcessing_.export(outfile, level, namespace_, name_='dataProcessing', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataProcessingListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dataProcessing=[\n')
        level += 1
        for dataProcessing_ in self.dataProcessing:
            showIndent(outfile, level)
            outfile.write('model_.DataProcessingType(\n')
            dataProcessing_.exportLiteral(outfile, level, name_='DataProcessingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataProcessing':
            obj_ = DataProcessingType.factory()
            obj_.build(child_)
            self.dataProcessing.append(obj_)
# end class DataProcessingListType


class ProcessingMethodType(ParamGroupType):
    """This attributes allows a series of consecutive steps to be placed in
    the correct order.This attribute must reference the 'id' of the
    appropriate SoftwareType."""
    subclass = None
    superclass = ParamGroupType
    def __init__(self, referenceableParamGroupRef=None, cvParam=None, cvParamWithUnit=None, cvTerm=None, userParam=None, order=None, softwareRef=None):
        super(ProcessingMethodType, self).__init__(referenceableParamGroupRef, cvParam, cvParamWithUnit, cvTerm, userParam, )
        self.order = _cast(int, order)
        self.softwareRef = _cast(None, softwareRef)
        pass
    def factory(*args_, **kwargs_):
        if ProcessingMethodType.subclass:
            return ProcessingMethodType.subclass(*args_, **kwargs_)
        else:
            return ProcessingMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_softwareRef(self): return self.softwareRef
    def set_softwareRef(self, softwareRef): self.softwareRef = softwareRef
    def hasContent_(self):
        if (
            super(ProcessingMethodType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ProcessingMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessingMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ProcessingMethodType'):
        super(ProcessingMethodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessingMethodType')
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.softwareRef is not None and 'softwareRef' not in already_processed:
            already_processed.add('softwareRef')
            outfile.write(' softwareRef=%s' % (self.gds_format_string(quote_attrib(self.softwareRef).encode(ExternalEncoding), input_name='softwareRef'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ProcessingMethodType', fromsubclass_=False, pretty_print=True):
        super(ProcessingMethodType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessingMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            showIndent(outfile, level)
            outfile.write('order=%d,\n' % (self.order,))
        if self.softwareRef is not None and 'softwareRef' not in already_processed:
            already_processed.add('softwareRef')
            showIndent(outfile, level)
            outfile.write('softwareRef="%s",\n' % (self.softwareRef,))
        super(ProcessingMethodType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProcessingMethodType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            try:
                self.order = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.order < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('softwareRef', node)
        if value is not None and 'softwareRef' not in already_processed:
            already_processed.add('softwareRef')
            self.softwareRef = value
        super(ProcessingMethodType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProcessingMethodType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProcessingMethodType


class BinaryDataArrayType(GeneratedsSuper):
    """True if the binary data was compressed with zlib before encoding as
    base64This optional attribute may reference the 'id' attribute
    of the appropriate dataProcessing.The encoded length of the
    binary data array.64-bit or 32-bit precision floats"""
    subclass = None
    superclass = None
    def __init__(self, byteFormat=None, encodedLength=None, compressed=None, dataProcessingRef=None, valueOf_=None):
        self.byteFormat = _cast(None, byteFormat)
        self.encodedLength = _cast(int, encodedLength)
        self.compressed = _cast(bool, compressed)
        self.dataProcessingRef = _cast(None, dataProcessingRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if BinaryDataArrayType.subclass:
            return BinaryDataArrayType.subclass(*args_, **kwargs_)
        else:
            return BinaryDataArrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_byteFormat(self): return self.byteFormat
    def set_byteFormat(self, byteFormat): self.byteFormat = byteFormat
    def get_encodedLength(self): return self.encodedLength
    def set_encodedLength(self, encodedLength): self.encodedLength = encodedLength
    def get_compressed(self): return self.compressed
    def set_compressed(self, compressed): self.compressed = compressed
    def get_dataProcessingRef(self): return self.dataProcessingRef
    def set_dataProcessingRef(self, dataProcessingRef): self.dataProcessingRef = dataProcessingRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='BinaryDataArrayType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BinaryDataArrayType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='BinaryDataArrayType'):
        if self.byteFormat is not None and 'byteFormat' not in already_processed:
            already_processed.add('byteFormat')
            outfile.write(' byteFormat=%s' % (self.gds_format_string(quote_attrib(self.byteFormat).encode(ExternalEncoding), input_name='byteFormat'), ))
        if self.encodedLength is not None and 'encodedLength' not in already_processed:
            already_processed.add('encodedLength')
            outfile.write(' encodedLength="%s"' % self.gds_format_integer(self.encodedLength, input_name='encodedLength'))
        if self.compressed is not None and 'compressed' not in already_processed:
            already_processed.add('compressed')
            outfile.write(' compressed="%s"' % self.gds_format_boolean(self.compressed, input_name='compressed'))
        if self.dataProcessingRef is not None and 'dataProcessingRef' not in already_processed:
            already_processed.add('dataProcessingRef')
            outfile.write(' dataProcessingRef=%s' % (self.gds_format_string(quote_attrib(self.dataProcessingRef).encode(ExternalEncoding), input_name='dataProcessingRef'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='BinaryDataArrayType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BinaryDataArrayType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.byteFormat is not None and 'byteFormat' not in already_processed:
            already_processed.add('byteFormat')
            showIndent(outfile, level)
            outfile.write('byteFormat="%s",\n' % (self.byteFormat,))
        if self.encodedLength is not None and 'encodedLength' not in already_processed:
            already_processed.add('encodedLength')
            showIndent(outfile, level)
            outfile.write('encodedLength=%d,\n' % (self.encodedLength,))
        if self.compressed is not None and 'compressed' not in already_processed:
            already_processed.add('compressed')
            showIndent(outfile, level)
            outfile.write('compressed=%s,\n' % (self.compressed,))
        if self.dataProcessingRef is not None and 'dataProcessingRef' not in already_processed:
            already_processed.add('dataProcessingRef')
            showIndent(outfile, level)
            outfile.write('dataProcessingRef="%s",\n' % (self.dataProcessingRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('byteFormat', node)
        if value is not None and 'byteFormat' not in already_processed:
            already_processed.add('byteFormat')
            self.byteFormat = value
        value = find_attr_value_('encodedLength', node)
        if value is not None and 'encodedLength' not in already_processed:
            already_processed.add('encodedLength')
            try:
                self.encodedLength = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.encodedLength < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('compressed', node)
        if value is not None and 'compressed' not in already_processed:
            already_processed.add('compressed')
            if value in ('true', '1'):
                self.compressed = True
            elif value in ('false', '0'):
                self.compressed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dataProcessingRef', node)
        if value is not None and 'dataProcessingRef' not in already_processed:
            already_processed.add('dataProcessingRef')
            self.dataProcessingRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BinaryDataArrayType


class SoluteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, concentrationInSample=None):
        self.name = _cast(None, name)
        self.concentrationInSample = concentrationInSample
    def factory(*args_, **kwargs_):
        if SoluteType.subclass:
            return SoluteType.subclass(*args_, **kwargs_)
        else:
            return SoluteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_concentrationInSample(self): return self.concentrationInSample
    def set_concentrationInSample(self, concentrationInSample): self.concentrationInSample = concentrationInSample
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.concentrationInSample is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SoluteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoluteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SoluteType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SoluteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.concentrationInSample is not None:
            self.concentrationInSample.export(outfile, level, namespace_, name_='concentrationInSample', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SoluteType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.concentrationInSample is not None:
            showIndent(outfile, level)
            outfile.write('concentrationInSample=model_.ValueWithUnitType(\n')
            self.concentrationInSample.exportLiteral(outfile, level, name_='concentrationInSample')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'concentrationInSample':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.concentrationInSample = obj_
# end class SoluteType


class TemperatureType(GeneratedsSuper):
    """A temperature and references to a unit from the unit ontology."""
    subclass = None
    superclass = None
    def __init__(self, temperatureUnitID=None, temperature=None, temperatureUnitName=None):
        self.temperatureUnitID = _cast(None, temperatureUnitID)
        self.temperature = _cast(float, temperature)
        self.temperatureUnitName = _cast(None, temperatureUnitName)
        pass
    def factory(*args_, **kwargs_):
        if TemperatureType.subclass:
            return TemperatureType.subclass(*args_, **kwargs_)
        else:
            return TemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_temperatureUnitID(self): return self.temperatureUnitID
    def set_temperatureUnitID(self, temperatureUnitID): self.temperatureUnitID = temperatureUnitID
    def get_temperature(self): return self.temperature
    def set_temperature(self, temperature): self.temperature = temperature
    def get_temperatureUnitName(self): return self.temperatureUnitName
    def set_temperatureUnitName(self, temperatureUnitName): self.temperatureUnitName = temperatureUnitName
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='TemperatureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemperatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='TemperatureType'):
        if self.temperatureUnitID is not None and 'temperatureUnitID' not in already_processed:
            already_processed.add('temperatureUnitID')
            outfile.write(' temperatureUnitID=%s' % (self.gds_format_string(quote_attrib(self.temperatureUnitID).encode(ExternalEncoding), input_name='temperatureUnitID'), ))
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            outfile.write(' temperature="%s"' % self.gds_format_float(self.temperature, input_name='temperature'))
        if self.temperatureUnitName is not None and 'temperatureUnitName' not in already_processed:
            already_processed.add('temperatureUnitName')
            outfile.write(' temperatureUnitName=%s' % (self.gds_format_string(quote_attrib(self.temperatureUnitName).encode(ExternalEncoding), input_name='temperatureUnitName'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='TemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TemperatureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.temperatureUnitID is not None and 'temperatureUnitID' not in already_processed:
            already_processed.add('temperatureUnitID')
            showIndent(outfile, level)
            outfile.write('temperatureUnitID="%s",\n' % (self.temperatureUnitID,))
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            showIndent(outfile, level)
            outfile.write('temperature=%f,\n' % (self.temperature,))
        if self.temperatureUnitName is not None and 'temperatureUnitName' not in already_processed:
            already_processed.add('temperatureUnitName')
            showIndent(outfile, level)
            outfile.write('temperatureUnitName="%s",\n' % (self.temperatureUnitName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('temperatureUnitID', node)
        if value is not None and 'temperatureUnitID' not in already_processed:
            already_processed.add('temperatureUnitID')
            self.temperatureUnitID = value
        value = find_attr_value_('temperature', node)
        if value is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            try:
                self.temperature = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (temperature): %s' % exp)
        value = find_attr_value_('temperatureUnitName', node)
        if value is not None and 'temperatureUnitName' not in already_processed:
            already_processed.add('temperatureUnitName')
            self.temperatureUnitName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemperatureType


class AdditionalSoluteListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, solute=None):
        if solute is None:
            self.solute = []
        else:
            self.solute = solute
    def factory(*args_, **kwargs_):
        if AdditionalSoluteListType.subclass:
            return AdditionalSoluteListType.subclass(*args_, **kwargs_)
        else:
            return AdditionalSoluteListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_solute(self): return self.solute
    def set_solute(self, solute): self.solute = solute
    def add_solute(self, value): self.solute.append(value)
    def insert_solute(self, index, value): self.solute[index] = value
    def hasContent_(self):
        if (
            self.solute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AdditionalSoluteListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalSoluteListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AdditionalSoluteListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AdditionalSoluteListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for solute_ in self.solute:
            solute_.export(outfile, level, namespace_, name_='solute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AdditionalSoluteListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('solute=[\n')
        level += 1
        for solute_ in self.solute:
            showIndent(outfile, level)
            outfile.write('model_.SoluteType(\n')
            solute_.exportLiteral(outfile, level, name_='SoluteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'solute':
            obj_ = SoluteType.factory()
            obj_.build(child_)
            self.solute.append(obj_)
# end class AdditionalSoluteListType


class AcquisitionDimensionParameterSetType(GeneratedsSuper):
    """Descriptions of the acquisition parameters set prior to the start of
    data acquisition specific to each NMR analysis dimension."""
    subclass = None
    superclass = None
    def __init__(self, numberOfDataPoints=None, decoupled=None, acquisitionNucleus=None, gammaB1PulseFieldStrength=None, sweepWidth=None, irradiationFrequency=None, decouplingMethod=None, samplingStrategy=None, samplingTimePoints=None):
        self.numberOfDataPoints = _cast(int, numberOfDataPoints)
        self.decoupled = _cast(bool, decoupled)
        self.acquisitionNucleus = acquisitionNucleus
        self.gammaB1PulseFieldStrength = gammaB1PulseFieldStrength
        self.sweepWidth = sweepWidth
        self.irradiationFrequency = irradiationFrequency
        self.decouplingMethod = decouplingMethod
        self.samplingStrategy = samplingStrategy
        self.samplingTimePoints = samplingTimePoints
    def factory(*args_, **kwargs_):
        if AcquisitionDimensionParameterSetType.subclass:
            return AcquisitionDimensionParameterSetType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionDimensionParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acquisitionNucleus(self): return self.acquisitionNucleus
    def set_acquisitionNucleus(self, acquisitionNucleus): self.acquisitionNucleus = acquisitionNucleus
    def get_gammaB1PulseFieldStrength(self): return self.gammaB1PulseFieldStrength
    def set_gammaB1PulseFieldStrength(self, gammaB1PulseFieldStrength): self.gammaB1PulseFieldStrength = gammaB1PulseFieldStrength
    def get_sweepWidth(self): return self.sweepWidth
    def set_sweepWidth(self, sweepWidth): self.sweepWidth = sweepWidth
    def get_irradiationFrequency(self): return self.irradiationFrequency
    def set_irradiationFrequency(self, irradiationFrequency): self.irradiationFrequency = irradiationFrequency
    def get_decouplingMethod(self): return self.decouplingMethod
    def set_decouplingMethod(self, decouplingMethod): self.decouplingMethod = decouplingMethod
    def get_samplingStrategy(self): return self.samplingStrategy
    def set_samplingStrategy(self, samplingStrategy): self.samplingStrategy = samplingStrategy
    def get_samplingTimePoints(self): return self.samplingTimePoints
    def set_samplingTimePoints(self, samplingTimePoints): self.samplingTimePoints = samplingTimePoints
    def get_numberOfDataPoints(self): return self.numberOfDataPoints
    def set_numberOfDataPoints(self, numberOfDataPoints): self.numberOfDataPoints = numberOfDataPoints
    def get_decoupled(self): return self.decoupled
    def set_decoupled(self, decoupled): self.decoupled = decoupled
    def hasContent_(self):
        if (
            self.acquisitionNucleus is not None or
            self.gammaB1PulseFieldStrength is not None or
            self.sweepWidth is not None or
            self.irradiationFrequency is not None or
            self.decouplingMethod is not None or
            self.samplingStrategy is not None or
            self.samplingTimePoints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AcquisitionDimensionParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionDimensionParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AcquisitionDimensionParameterSetType'):
        if self.numberOfDataPoints is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            outfile.write(' numberOfDataPoints="%s"' % self.gds_format_integer(self.numberOfDataPoints, input_name='numberOfDataPoints'))
        if self.decoupled is not None and 'decoupled' not in already_processed:
            already_processed.add('decoupled')
            outfile.write(' decoupled="%s"' % self.gds_format_boolean(self.decoupled, input_name='decoupled'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AcquisitionDimensionParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acquisitionNucleus is not None:
            self.acquisitionNucleus.export(outfile, level, namespace_, name_='acquisitionNucleus', pretty_print=pretty_print)
        if self.gammaB1PulseFieldStrength is not None:
            self.gammaB1PulseFieldStrength.export(outfile, level, namespace_, name_='gammaB1PulseFieldStrength', pretty_print=pretty_print)
        if self.sweepWidth is not None:
            self.sweepWidth.export(outfile, level, namespace_, name_='sweepWidth', pretty_print=pretty_print)
        if self.irradiationFrequency is not None:
            self.irradiationFrequency.export(outfile, level, namespace_, name_='irradiationFrequency', pretty_print=pretty_print)
        if self.decouplingMethod is not None:
            self.decouplingMethod.export(outfile, level, namespace_, name_='decouplingMethod', pretty_print=pretty_print)
        if self.samplingStrategy is not None:
            self.samplingStrategy.export(outfile, level, namespace_, name_='samplingStrategy', pretty_print=pretty_print)
        if self.samplingTimePoints is not None:
            self.samplingTimePoints.export(outfile, level, namespace_, name_='samplingTimePoints', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcquisitionDimensionParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfDataPoints is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            showIndent(outfile, level)
            outfile.write('numberOfDataPoints=%d,\n' % (self.numberOfDataPoints,))
        if self.decoupled is not None and 'decoupled' not in already_processed:
            already_processed.add('decoupled')
            showIndent(outfile, level)
            outfile.write('decoupled=%s,\n' % (self.decoupled,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.acquisitionNucleus is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionNucleus=model_.CVTermType(\n')
            self.acquisitionNucleus.exportLiteral(outfile, level, name_='acquisitionNucleus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gammaB1PulseFieldStrength is not None:
            showIndent(outfile, level)
            outfile.write('gammaB1PulseFieldStrength=model_.ValueWithUnitType(\n')
            self.gammaB1PulseFieldStrength.exportLiteral(outfile, level, name_='gammaB1PulseFieldStrength')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sweepWidth is not None:
            showIndent(outfile, level)
            outfile.write('sweepWidth=model_.ValueWithUnitType(\n')
            self.sweepWidth.exportLiteral(outfile, level, name_='sweepWidth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.irradiationFrequency is not None:
            showIndent(outfile, level)
            outfile.write('irradiationFrequency=model_.ValueWithUnitType(\n')
            self.irradiationFrequency.exportLiteral(outfile, level, name_='irradiationFrequency')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.decouplingMethod is not None:
            showIndent(outfile, level)
            outfile.write('decouplingMethod=model_.CVTermType(\n')
            self.decouplingMethod.exportLiteral(outfile, level, name_='decouplingMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.samplingStrategy is not None:
            showIndent(outfile, level)
            outfile.write('samplingStrategy=model_.CVTermType(\n')
            self.samplingStrategy.exportLiteral(outfile, level, name_='samplingStrategy')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.samplingTimePoints is not None:
            showIndent(outfile, level)
            outfile.write('samplingTimePoints=model_.BinaryDataArrayType(\n')
            self.samplingTimePoints.exportLiteral(outfile, level, name_='samplingTimePoints')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfDataPoints', node)
        if value is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            try:
                self.numberOfDataPoints = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('decoupled', node)
        if value is not None and 'decoupled' not in already_processed:
            already_processed.add('decoupled')
            if value in ('true', '1'):
                self.decoupled = True
            elif value in ('false', '0'):
                self.decoupled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acquisitionNucleus':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.acquisitionNucleus = obj_
        elif nodeName_ == 'gammaB1PulseFieldStrength':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.gammaB1PulseFieldStrength = obj_
        elif nodeName_ == 'sweepWidth':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.sweepWidth = obj_
        elif nodeName_ == 'irradiationFrequency':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.irradiationFrequency = obj_
        elif nodeName_ == 'decouplingMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.decouplingMethod = obj_
        elif nodeName_ == 'samplingStrategy':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.samplingStrategy = obj_
        elif nodeName_ == 'samplingTimePoints':
            obj_ = BinaryDataArrayType.factory()
            obj_.build(child_)
            self.samplingTimePoints = obj_
# end class AcquisitionDimensionParameterSetType


class AcquisitionIndirectDimensionParameterSetType(GeneratedsSuper):
    """Descriptions of the acquisition parameters set prior to the start of
    data acquisition specific to each NMR analysis dimension."""
    subclass = None
    superclass = None
    def __init__(self, numberOfDataPoints=None, acquisitionParamsFileRef=None, decoupled=None, acquisitionNucleus=None, gammaB1PulseFieldStrength=None, sweepWidth=None, timeDomain=None, encodingMethod=None, irradiationFrequency=None):
        self.numberOfDataPoints = _cast(int, numberOfDataPoints)
        self.acquisitionParamsFileRef = _cast(None, acquisitionParamsFileRef)
        self.decoupled = _cast(bool, decoupled)
        self.acquisitionNucleus = acquisitionNucleus
        self.gammaB1PulseFieldStrength = gammaB1PulseFieldStrength
        self.sweepWidth = sweepWidth
        self.timeDomain = timeDomain
        self.encodingMethod = encodingMethod
        self.irradiationFrequency = irradiationFrequency
    def factory(*args_, **kwargs_):
        if AcquisitionIndirectDimensionParameterSetType.subclass:
            return AcquisitionIndirectDimensionParameterSetType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionIndirectDimensionParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acquisitionNucleus(self): return self.acquisitionNucleus
    def set_acquisitionNucleus(self, acquisitionNucleus): self.acquisitionNucleus = acquisitionNucleus
    def get_gammaB1PulseFieldStrength(self): return self.gammaB1PulseFieldStrength
    def set_gammaB1PulseFieldStrength(self, gammaB1PulseFieldStrength): self.gammaB1PulseFieldStrength = gammaB1PulseFieldStrength
    def get_sweepWidth(self): return self.sweepWidth
    def set_sweepWidth(self, sweepWidth): self.sweepWidth = sweepWidth
    def get_timeDomain(self): return self.timeDomain
    def set_timeDomain(self, timeDomain): self.timeDomain = timeDomain
    def get_encodingMethod(self): return self.encodingMethod
    def set_encodingMethod(self, encodingMethod): self.encodingMethod = encodingMethod
    def get_irradiationFrequency(self): return self.irradiationFrequency
    def set_irradiationFrequency(self, irradiationFrequency): self.irradiationFrequency = irradiationFrequency
    def get_numberOfDataPoints(self): return self.numberOfDataPoints
    def set_numberOfDataPoints(self, numberOfDataPoints): self.numberOfDataPoints = numberOfDataPoints
    def get_acquisitionParamsFileRef(self): return self.acquisitionParamsFileRef
    def set_acquisitionParamsFileRef(self, acquisitionParamsFileRef): self.acquisitionParamsFileRef = acquisitionParamsFileRef
    def get_decoupled(self): return self.decoupled
    def set_decoupled(self, decoupled): self.decoupled = decoupled
    def hasContent_(self):
        if (
            self.acquisitionNucleus is not None or
            self.gammaB1PulseFieldStrength is not None or
            self.sweepWidth is not None or
            self.timeDomain is not None or
            self.encodingMethod is not None or
            self.irradiationFrequency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AcquisitionIndirectDimensionParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionIndirectDimensionParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AcquisitionIndirectDimensionParameterSetType'):
        if self.numberOfDataPoints is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            outfile.write(' numberOfDataPoints="%s"' % self.gds_format_integer(self.numberOfDataPoints, input_name='numberOfDataPoints'))
        if self.acquisitionParamsFileRef is not None and 'acquisitionParamsFileRef' not in already_processed:
            already_processed.add('acquisitionParamsFileRef')
            outfile.write(' acquisitionParamsFileRef=%s' % (self.gds_format_string(quote_attrib(self.acquisitionParamsFileRef).encode(ExternalEncoding), input_name='acquisitionParamsFileRef'), ))
        if self.decoupled is not None and 'decoupled' not in already_processed:
            already_processed.add('decoupled')
            outfile.write(' decoupled="%s"' % self.gds_format_boolean(self.decoupled, input_name='decoupled'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AcquisitionIndirectDimensionParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acquisitionNucleus is not None:
            self.acquisitionNucleus.export(outfile, level, namespace_, name_='acquisitionNucleus', pretty_print=pretty_print)
        if self.gammaB1PulseFieldStrength is not None:
            self.gammaB1PulseFieldStrength.export(outfile, level, namespace_, name_='gammaB1PulseFieldStrength', pretty_print=pretty_print)
        if self.sweepWidth is not None:
            self.sweepWidth.export(outfile, level, namespace_, name_='sweepWidth', pretty_print=pretty_print)
        if self.timeDomain is not None:
            self.timeDomain.export(outfile, level, namespace_, name_='timeDomain', pretty_print=pretty_print)
        if self.encodingMethod is not None:
            self.encodingMethod.export(outfile, level, namespace_, name_='encodingMethod', pretty_print=pretty_print)
        if self.irradiationFrequency is not None:
            self.irradiationFrequency.export(outfile, level, namespace_, name_='irradiationFrequency', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcquisitionIndirectDimensionParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfDataPoints is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            showIndent(outfile, level)
            outfile.write('numberOfDataPoints=%d,\n' % (self.numberOfDataPoints,))
        if self.acquisitionParamsFileRef is not None and 'acquisitionParamsFileRef' not in already_processed:
            already_processed.add('acquisitionParamsFileRef')
            showIndent(outfile, level)
            outfile.write('acquisitionParamsFileRef="%s",\n' % (self.acquisitionParamsFileRef,))
        if self.decoupled is not None and 'decoupled' not in already_processed:
            already_processed.add('decoupled')
            showIndent(outfile, level)
            outfile.write('decoupled=%s,\n' % (self.decoupled,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.acquisitionNucleus is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionNucleus=model_.CVTermType(\n')
            self.acquisitionNucleus.exportLiteral(outfile, level, name_='acquisitionNucleus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gammaB1PulseFieldStrength is not None:
            showIndent(outfile, level)
            outfile.write('gammaB1PulseFieldStrength=model_.ValueWithUnitType(\n')
            self.gammaB1PulseFieldStrength.exportLiteral(outfile, level, name_='gammaB1PulseFieldStrength')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sweepWidth is not None:
            showIndent(outfile, level)
            outfile.write('sweepWidth=model_.ValueWithUnitType(\n')
            self.sweepWidth.exportLiteral(outfile, level, name_='sweepWidth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeDomain is not None:
            showIndent(outfile, level)
            outfile.write('timeDomain=model_.BinaryDataArrayType(\n')
            self.timeDomain.exportLiteral(outfile, level, name_='timeDomain')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.encodingMethod is not None:
            showIndent(outfile, level)
            outfile.write('encodingMethod=model_.CVTermType(\n')
            self.encodingMethod.exportLiteral(outfile, level, name_='encodingMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.irradiationFrequency is not None:
            showIndent(outfile, level)
            outfile.write('irradiationFrequency=model_.ValueWithUnitType(\n')
            self.irradiationFrequency.exportLiteral(outfile, level, name_='irradiationFrequency')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfDataPoints', node)
        if value is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            try:
                self.numberOfDataPoints = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('acquisitionParamsFileRef', node)
        if value is not None and 'acquisitionParamsFileRef' not in already_processed:
            already_processed.add('acquisitionParamsFileRef')
            self.acquisitionParamsFileRef = value
        value = find_attr_value_('decoupled', node)
        if value is not None and 'decoupled' not in already_processed:
            already_processed.add('decoupled')
            if value in ('true', '1'):
                self.decoupled = True
            elif value in ('false', '0'):
                self.decoupled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acquisitionNucleus':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.acquisitionNucleus = obj_
        elif nodeName_ == 'gammaB1PulseFieldStrength':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.gammaB1PulseFieldStrength = obj_
        elif nodeName_ == 'sweepWidth':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.sweepWidth = obj_
        elif nodeName_ == 'timeDomain':
            obj_ = BinaryDataArrayType.factory()
            obj_.build(child_)
            self.timeDomain = obj_
        elif nodeName_ == 'encodingMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.encodingMethod = obj_
        elif nodeName_ == 'irradiationFrequency':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.irradiationFrequency = obj_
# end class AcquisitionIndirectDimensionParameterSetType


class AcquisitionParameterSetType(GeneratedsSuper):
    """Base type for the list with the descriptions of the acquisition
    settings applied prior to the start of data acquisition."""
    subclass = None
    superclass = None
    def __init__(self, numberOfScans=None, numberOfSteadyStateScans=None, contactRefList=None, acquisitionParameterFileRefList=None, softwareRef=None, sampleContainer=None, sampleAcquisitionTemperature=None, solventSuppressionMethod=None, spinningRate=None, relaxationDelay=None, pulseSequence=None, shapedPulseFile=None, extensiontype_=None):
        self.numberOfScans = _cast(int, numberOfScans)
        self.numberOfSteadyStateScans = _cast(int, numberOfSteadyStateScans)
        self.contactRefList = contactRefList
        self.acquisitionParameterFileRefList = acquisitionParameterFileRefList
        self.softwareRef = softwareRef
        self.sampleContainer = sampleContainer
        self.sampleAcquisitionTemperature = sampleAcquisitionTemperature
        self.solventSuppressionMethod = solventSuppressionMethod
        self.spinningRate = spinningRate
        self.relaxationDelay = relaxationDelay
        self.pulseSequence = pulseSequence
        self.shapedPulseFile = shapedPulseFile
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AcquisitionParameterSetType.subclass:
            return AcquisitionParameterSetType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contactRefList(self): return self.contactRefList
    def set_contactRefList(self, contactRefList): self.contactRefList = contactRefList
    def get_acquisitionParameterFileRefList(self): return self.acquisitionParameterFileRefList
    def set_acquisitionParameterFileRefList(self, acquisitionParameterFileRefList): self.acquisitionParameterFileRefList = acquisitionParameterFileRefList
    def get_softwareRef(self): return self.softwareRef
    def set_softwareRef(self, softwareRef): self.softwareRef = softwareRef
    def get_sampleContainer(self): return self.sampleContainer
    def set_sampleContainer(self, sampleContainer): self.sampleContainer = sampleContainer
    def get_sampleAcquisitionTemperature(self): return self.sampleAcquisitionTemperature
    def set_sampleAcquisitionTemperature(self, sampleAcquisitionTemperature): self.sampleAcquisitionTemperature = sampleAcquisitionTemperature
    def get_solventSuppressionMethod(self): return self.solventSuppressionMethod
    def set_solventSuppressionMethod(self, solventSuppressionMethod): self.solventSuppressionMethod = solventSuppressionMethod
    def get_spinningRate(self): return self.spinningRate
    def set_spinningRate(self, spinningRate): self.spinningRate = spinningRate
    def get_relaxationDelay(self): return self.relaxationDelay
    def set_relaxationDelay(self, relaxationDelay): self.relaxationDelay = relaxationDelay
    def get_pulseSequence(self): return self.pulseSequence
    def set_pulseSequence(self, pulseSequence): self.pulseSequence = pulseSequence
    def get_shapedPulseFile(self): return self.shapedPulseFile
    def set_shapedPulseFile(self, shapedPulseFile): self.shapedPulseFile = shapedPulseFile
    def get_numberOfScans(self): return self.numberOfScans
    def set_numberOfScans(self, numberOfScans): self.numberOfScans = numberOfScans
    def get_numberOfSteadyStateScans(self): return self.numberOfSteadyStateScans
    def set_numberOfSteadyStateScans(self, numberOfSteadyStateScans): self.numberOfSteadyStateScans = numberOfSteadyStateScans
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.contactRefList is not None or
            self.acquisitionParameterFileRefList is not None or
            self.softwareRef is not None or
            self.sampleContainer is not None or
            self.sampleAcquisitionTemperature is not None or
            self.solventSuppressionMethod is not None or
            self.spinningRate is not None or
            self.relaxationDelay is not None or
            self.pulseSequence is not None or
            self.shapedPulseFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AcquisitionParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AcquisitionParameterSetType'):
        if self.numberOfScans is not None and 'numberOfScans' not in already_processed:
            already_processed.add('numberOfScans')
            outfile.write(' numberOfScans="%s"' % self.gds_format_integer(self.numberOfScans, input_name='numberOfScans'))
        if self.numberOfSteadyStateScans is not None and 'numberOfSteadyStateScans' not in already_processed:
            already_processed.add('numberOfSteadyStateScans')
            outfile.write(' numberOfSteadyStateScans="%s"' % self.gds_format_integer(self.numberOfSteadyStateScans, input_name='numberOfSteadyStateScans'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AcquisitionParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contactRefList is not None:
            self.contactRefList.export(outfile, level, namespace_, name_='contactRefList', pretty_print=pretty_print)
        if self.acquisitionParameterFileRefList is not None:
            self.acquisitionParameterFileRefList.export(outfile, level, namespace_, name_='acquisitionParameterFileRefList', pretty_print=pretty_print)
        if self.softwareRef is not None:
            self.softwareRef.export(outfile, level, namespace_, name_='softwareRef', pretty_print=pretty_print)
        if self.sampleContainer is not None:
            self.sampleContainer.export(outfile, level, namespace_, name_='sampleContainer', pretty_print=pretty_print)
        if self.sampleAcquisitionTemperature is not None:
            self.sampleAcquisitionTemperature.export(outfile, level, namespace_, name_='sampleAcquisitionTemperature', pretty_print=pretty_print)
        if self.solventSuppressionMethod is not None:
            self.solventSuppressionMethod.export(outfile, level, namespace_, name_='solventSuppressionMethod', pretty_print=pretty_print)
        if self.spinningRate is not None:
            self.spinningRate.export(outfile, level, namespace_, name_='spinningRate', pretty_print=pretty_print)
        if self.relaxationDelay is not None:
            self.relaxationDelay.export(outfile, level, namespace_, name_='relaxationDelay', pretty_print=pretty_print)
        if self.pulseSequence is not None:
            self.pulseSequence.export(outfile, level, namespace_, name_='pulseSequence', pretty_print=pretty_print)
        if self.shapedPulseFile is not None:
            self.shapedPulseFile.export(outfile, level, namespace_, name_='shapedPulseFile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcquisitionParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfScans is not None and 'numberOfScans' not in already_processed:
            already_processed.add('numberOfScans')
            showIndent(outfile, level)
            outfile.write('numberOfScans=%d,\n' % (self.numberOfScans,))
        if self.numberOfSteadyStateScans is not None and 'numberOfSteadyStateScans' not in already_processed:
            already_processed.add('numberOfSteadyStateScans')
            showIndent(outfile, level)
            outfile.write('numberOfSteadyStateScans=%d,\n' % (self.numberOfSteadyStateScans,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.contactRefList is not None:
            showIndent(outfile, level)
            outfile.write('contactRefList=model_.ContactRefListType(\n')
            self.contactRefList.exportLiteral(outfile, level, name_='contactRefList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.acquisitionParameterFileRefList is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionParameterFileRefList=model_.SourceFileRefListType(\n')
            self.acquisitionParameterFileRefList.exportLiteral(outfile, level, name_='acquisitionParameterFileRefList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.softwareRef is not None:
            showIndent(outfile, level)
            outfile.write('softwareRef=model_.SoftwareRefType(\n')
            self.softwareRef.exportLiteral(outfile, level, name_='softwareRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sampleContainer is not None:
            showIndent(outfile, level)
            outfile.write('sampleContainer=model_.CVTermType(\n')
            self.sampleContainer.exportLiteral(outfile, level, name_='sampleContainer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sampleAcquisitionTemperature is not None:
            showIndent(outfile, level)
            outfile.write('sampleAcquisitionTemperature=model_.ValueWithUnitType(\n')
            self.sampleAcquisitionTemperature.exportLiteral(outfile, level, name_='sampleAcquisitionTemperature')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.solventSuppressionMethod is not None:
            showIndent(outfile, level)
            outfile.write('solventSuppressionMethod=model_.CVParamType(\n')
            self.solventSuppressionMethod.exportLiteral(outfile, level, name_='solventSuppressionMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spinningRate is not None:
            showIndent(outfile, level)
            outfile.write('spinningRate=model_.ValueWithUnitType(\n')
            self.spinningRate.exportLiteral(outfile, level, name_='spinningRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.relaxationDelay is not None:
            showIndent(outfile, level)
            outfile.write('relaxationDelay=model_.ValueWithUnitType(\n')
            self.relaxationDelay.exportLiteral(outfile, level, name_='relaxationDelay')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pulseSequence is not None:
            showIndent(outfile, level)
            outfile.write('pulseSequence=model_.PulseSequenceType(\n')
            self.pulseSequence.exportLiteral(outfile, level, name_='pulseSequence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.shapedPulseFile is not None:
            showIndent(outfile, level)
            outfile.write('shapedPulseFile=model_.SourceFileRefType(\n')
            self.shapedPulseFile.exportLiteral(outfile, level, name_='shapedPulseFile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfScans', node)
        if value is not None and 'numberOfScans' not in already_processed:
            already_processed.add('numberOfScans')
            try:
                self.numberOfScans = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfSteadyStateScans', node)
        if value is not None and 'numberOfSteadyStateScans' not in already_processed:
            already_processed.add('numberOfSteadyStateScans')
            try:
                self.numberOfSteadyStateScans = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contactRefList':
            obj_ = ContactRefListType.factory()
            obj_.build(child_)
            self.contactRefList = obj_
        elif nodeName_ == 'acquisitionParameterFileRefList':
            obj_ = SourceFileRefListType.factory()
            obj_.build(child_)
            self.acquisitionParameterFileRefList = obj_
        elif nodeName_ == 'softwareRef':
            obj_ = SoftwareRefType.factory()
            obj_.build(child_)
            self.softwareRef = obj_
        elif nodeName_ == 'sampleContainer':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.sampleContainer = obj_
        elif nodeName_ == 'sampleAcquisitionTemperature':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.sampleAcquisitionTemperature = obj_
        elif nodeName_ == 'solventSuppressionMethod':
            obj_ = CVParamType.factory()
            obj_.build(child_)
            self.solventSuppressionMethod = obj_
        elif nodeName_ == 'spinningRate':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.spinningRate = obj_
        elif nodeName_ == 'relaxationDelay':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.relaxationDelay = obj_
        elif nodeName_ == 'pulseSequence':
            obj_ = PulseSequenceType.factory()
            obj_.build(child_)
            self.pulseSequence = obj_
        elif nodeName_ == 'shapedPulseFile':
            obj_ = SourceFileRefType.factory()
            obj_.build(child_)
            self.shapedPulseFile = obj_
# end class AcquisitionParameterSetType


class AcquisitionParameterSet1DType(AcquisitionParameterSetType):
    subclass = None
    superclass = AcquisitionParameterSetType
    def __init__(self, numberOfScans=None, numberOfSteadyStateScans=None, contactRefList=None, acquisitionParameterFileRefList=None, softwareRef=None, sampleContainer=None, sampleAcquisitionTemperature=None, solventSuppressionMethod=None, spinningRate=None, relaxationDelay=None, pulseSequence=None, shapedPulseFile=None, DirectDimensionParameterSet=None):
        super(AcquisitionParameterSet1DType, self).__init__(numberOfScans, numberOfSteadyStateScans, contactRefList, acquisitionParameterFileRefList, softwareRef, sampleContainer, sampleAcquisitionTemperature, solventSuppressionMethod, spinningRate, relaxationDelay, pulseSequence, shapedPulseFile, )
        self.DirectDimensionParameterSet = DirectDimensionParameterSet
    def factory(*args_, **kwargs_):
        if AcquisitionParameterSet1DType.subclass:
            return AcquisitionParameterSet1DType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionParameterSet1DType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DirectDimensionParameterSet(self): return self.DirectDimensionParameterSet
    def set_DirectDimensionParameterSet(self, DirectDimensionParameterSet): self.DirectDimensionParameterSet = DirectDimensionParameterSet
    def hasContent_(self):
        if (
            self.DirectDimensionParameterSet is not None or
            super(AcquisitionParameterSet1DType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AcquisitionParameterSet1DType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionParameterSet1DType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AcquisitionParameterSet1DType'):
        super(AcquisitionParameterSet1DType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionParameterSet1DType')
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AcquisitionParameterSet1DType', fromsubclass_=False, pretty_print=True):
        super(AcquisitionParameterSet1DType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DirectDimensionParameterSet is not None:
            self.DirectDimensionParameterSet.export(outfile, level, namespace_, name_='DirectDimensionParameterSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcquisitionParameterSet1DType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AcquisitionParameterSet1DType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AcquisitionParameterSet1DType, self).exportLiteralChildren(outfile, level, name_)
        if self.DirectDimensionParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('DirectDimensionParameterSet=model_.AcquisitionDimensionParameterSetType(\n')
            self.DirectDimensionParameterSet.exportLiteral(outfile, level, name_='DirectDimensionParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AcquisitionParameterSet1DType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DirectDimensionParameterSet':
            obj_ = AcquisitionDimensionParameterSetType.factory()
            obj_.build(child_)
            self.DirectDimensionParameterSet = obj_
        super(AcquisitionParameterSet1DType, self).buildChildren(child_, node, nodeName_, True)
# end class AcquisitionParameterSet1DType


class AcquisitionParameterSetMultiDType(AcquisitionParameterSetType):
    subclass = None
    superclass = AcquisitionParameterSetType
    def __init__(self, numberOfScans=None, numberOfSteadyStateScans=None, contactRefList=None, acquisitionParameterFileRefList=None, softwareRef=None, sampleContainer=None, sampleAcquisitionTemperature=None, solventSuppressionMethod=None, spinningRate=None, relaxationDelay=None, pulseSequence=None, shapedPulseFile=None, hadamardParameterSet=None, directDimensionParameterSet=None, encodingScheme=None, indirectDimensionParameterSet=None):
        super(AcquisitionParameterSetMultiDType, self).__init__(numberOfScans, numberOfSteadyStateScans, contactRefList, acquisitionParameterFileRefList, softwareRef, sampleContainer, sampleAcquisitionTemperature, solventSuppressionMethod, spinningRate, relaxationDelay, pulseSequence, shapedPulseFile, )
        self.hadamardParameterSet = hadamardParameterSet
        self.directDimensionParameterSet = directDimensionParameterSet
        self.encodingScheme = encodingScheme
        if indirectDimensionParameterSet is None:
            self.indirectDimensionParameterSet = []
        else:
            self.indirectDimensionParameterSet = indirectDimensionParameterSet
    def factory(*args_, **kwargs_):
        if AcquisitionParameterSetMultiDType.subclass:
            return AcquisitionParameterSetMultiDType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionParameterSetMultiDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hadamardParameterSet(self): return self.hadamardParameterSet
    def set_hadamardParameterSet(self, hadamardParameterSet): self.hadamardParameterSet = hadamardParameterSet
    def get_directDimensionParameterSet(self): return self.directDimensionParameterSet
    def set_directDimensionParameterSet(self, directDimensionParameterSet): self.directDimensionParameterSet = directDimensionParameterSet
    def get_encodingScheme(self): return self.encodingScheme
    def set_encodingScheme(self, encodingScheme): self.encodingScheme = encodingScheme
    def get_indirectDimensionParameterSet(self): return self.indirectDimensionParameterSet
    def set_indirectDimensionParameterSet(self, indirectDimensionParameterSet): self.indirectDimensionParameterSet = indirectDimensionParameterSet
    def add_indirectDimensionParameterSet(self, value): self.indirectDimensionParameterSet.append(value)
    def insert_indirectDimensionParameterSet(self, index, value): self.indirectDimensionParameterSet[index] = value
    def hasContent_(self):
        if (
            self.hadamardParameterSet is not None or
            self.directDimensionParameterSet is not None or
            self.encodingScheme is not None or
            self.indirectDimensionParameterSet or
            super(AcquisitionParameterSetMultiDType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AcquisitionParameterSetMultiDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionParameterSetMultiDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AcquisitionParameterSetMultiDType'):
        super(AcquisitionParameterSetMultiDType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionParameterSetMultiDType')
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AcquisitionParameterSetMultiDType', fromsubclass_=False, pretty_print=True):
        super(AcquisitionParameterSetMultiDType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hadamardParameterSet is not None:
            self.hadamardParameterSet.export(outfile, level, namespace_, name_='hadamardParameterSet', pretty_print=pretty_print)
        if self.directDimensionParameterSet is not None:
            self.directDimensionParameterSet.export(outfile, level, namespace_, name_='directDimensionParameterSet', pretty_print=pretty_print)
        if self.encodingScheme is not None:
            self.encodingScheme.export(outfile, level, namespace_, name_='encodingScheme', pretty_print=pretty_print)
        for indirectDimensionParameterSet_ in self.indirectDimensionParameterSet:
            indirectDimensionParameterSet_.export(outfile, level, namespace_, name_='indirectDimensionParameterSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcquisitionParameterSetMultiDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AcquisitionParameterSetMultiDType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AcquisitionParameterSetMultiDType, self).exportLiteralChildren(outfile, level, name_)
        if self.hadamardParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('hadamardParameterSet=model_.hadamardParameterSetType(\n')
            self.hadamardParameterSet.exportLiteral(outfile, level, name_='hadamardParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.directDimensionParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('directDimensionParameterSet=model_.AcquisitionDimensionParameterSetType(\n')
            self.directDimensionParameterSet.exportLiteral(outfile, level, name_='directDimensionParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.encodingScheme is not None:
            showIndent(outfile, level)
            outfile.write('encodingScheme=model_.CVParamType(\n')
            self.encodingScheme.exportLiteral(outfile, level, name_='encodingScheme')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('indirectDimensionParameterSet=[\n')
        level += 1
        for indirectDimensionParameterSet_ in self.indirectDimensionParameterSet:
            showIndent(outfile, level)
            outfile.write('model_.AcquisitionDimensionParameterSetType(\n')
            indirectDimensionParameterSet_.exportLiteral(outfile, level, name_='AcquisitionDimensionParameterSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AcquisitionParameterSetMultiDType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hadamardParameterSet':
            obj_ = hadamardParameterSetType.factory()
            obj_.build(child_)
            self.hadamardParameterSet = obj_
        elif nodeName_ == 'directDimensionParameterSet':
            obj_ = AcquisitionDimensionParameterSetType.factory()
            obj_.build(child_)
            self.directDimensionParameterSet = obj_
        elif nodeName_ == 'encodingScheme':
            obj_ = CVParamType.factory()
            obj_.build(child_)
            self.encodingScheme = obj_
        elif nodeName_ == 'indirectDimensionParameterSet':
            obj_ = AcquisitionDimensionParameterSetType.factory()
            obj_.build(child_)
            self.indirectDimensionParameterSet.append(obj_)
        super(AcquisitionParameterSetMultiDType, self).buildChildren(child_, node, nodeName_, True)
# end class AcquisitionParameterSetMultiDType


class PulseSequenceType(ParamGroupType):
    """A list of references to the source files that define the pulse
    sequence, including pulse shape files, pulse sequence source
    code, pulse sequence parameter files, etc."""
    subclass = None
    superclass = ParamGroupType
    def __init__(self, referenceableParamGroupRef=None, cvParam=None, cvParamWithUnit=None, cvTerm=None, userParam=None, pulseSequenceFileRefList=None):
        super(PulseSequenceType, self).__init__(referenceableParamGroupRef, cvParam, cvParamWithUnit, cvTerm, userParam, )
        self.pulseSequenceFileRefList = pulseSequenceFileRefList
    def factory(*args_, **kwargs_):
        if PulseSequenceType.subclass:
            return PulseSequenceType.subclass(*args_, **kwargs_)
        else:
            return PulseSequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pulseSequenceFileRefList(self): return self.pulseSequenceFileRefList
    def set_pulseSequenceFileRefList(self, pulseSequenceFileRefList): self.pulseSequenceFileRefList = pulseSequenceFileRefList
    def hasContent_(self):
        if (
            self.pulseSequenceFileRefList is not None or
            super(PulseSequenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='PulseSequenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PulseSequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='PulseSequenceType'):
        super(PulseSequenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PulseSequenceType')
    def exportChildren(self, outfile, level, namespace_='dx:', name_='PulseSequenceType', fromsubclass_=False, pretty_print=True):
        super(PulseSequenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pulseSequenceFileRefList is not None:
            self.pulseSequenceFileRefList.export(outfile, level, namespace_, name_='pulseSequenceFileRefList', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PulseSequenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PulseSequenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PulseSequenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.pulseSequenceFileRefList is not None:
            showIndent(outfile, level)
            outfile.write('pulseSequenceFileRefList=model_.pulseSequenceFileRefListType(\n')
            self.pulseSequenceFileRefList.exportLiteral(outfile, level, name_='pulseSequenceFileRefList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PulseSequenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pulseSequenceFileRefList':
            obj_ = pulseSequenceFileRefListType.factory()
            obj_.build(child_)
            self.pulseSequenceFileRefList = obj_
        super(PulseSequenceType, self).buildChildren(child_, node, nodeName_, True)
# end class PulseSequenceType


class AcquisitionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, acquisition1D=None, acquisitionMultiD=None):
        self.acquisition1D = acquisition1D
        self.acquisitionMultiD = acquisitionMultiD
    def factory(*args_, **kwargs_):
        if AcquisitionType.subclass:
            return AcquisitionType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acquisition1D(self): return self.acquisition1D
    def set_acquisition1D(self, acquisition1D): self.acquisition1D = acquisition1D
    def get_acquisitionMultiD(self): return self.acquisitionMultiD
    def set_acquisitionMultiD(self, acquisitionMultiD): self.acquisitionMultiD = acquisitionMultiD
    def hasContent_(self):
        if (
            self.acquisition1D is not None or
            self.acquisitionMultiD is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AcquisitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AcquisitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AcquisitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acquisition1D is not None:
            self.acquisition1D.export(outfile, level, namespace_, name_='acquisition1D', pretty_print=pretty_print)
        if self.acquisitionMultiD is not None:
            self.acquisitionMultiD.export(outfile, level, namespace_, name_='acquisitionMultiD', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcquisitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.acquisition1D is not None:
            showIndent(outfile, level)
            outfile.write('acquisition1D=model_.Acquisition1DType(\n')
            self.acquisition1D.exportLiteral(outfile, level, name_='acquisition1D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.acquisitionMultiD is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionMultiD=model_.AcquisitionMultiDType(\n')
            self.acquisitionMultiD.exportLiteral(outfile, level, name_='acquisitionMultiD')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acquisition1D':
            obj_ = Acquisition1DType.factory()
            obj_.build(child_)
            self.acquisition1D = obj_
        elif nodeName_ == 'acquisitionMultiD':
            obj_ = AcquisitionMultiDType.factory()
            obj_.build(child_)
            self.acquisitionMultiD = obj_
# end class AcquisitionType


class Acquisition1DType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, acquisitionParameterSet=None, fidData=None):
        self.acquisitionParameterSet = acquisitionParameterSet
        self.fidData = fidData
    def factory(*args_, **kwargs_):
        if Acquisition1DType.subclass:
            return Acquisition1DType.subclass(*args_, **kwargs_)
        else:
            return Acquisition1DType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acquisitionParameterSet(self): return self.acquisitionParameterSet
    def set_acquisitionParameterSet(self, acquisitionParameterSet): self.acquisitionParameterSet = acquisitionParameterSet
    def get_fidData(self): return self.fidData
    def set_fidData(self, fidData): self.fidData = fidData
    def hasContent_(self):
        if (
            self.acquisitionParameterSet is not None or
            self.fidData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='Acquisition1DType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Acquisition1DType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='Acquisition1DType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='Acquisition1DType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acquisitionParameterSet is not None:
            self.acquisitionParameterSet.export(outfile, level, namespace_, name_='acquisitionParameterSet', pretty_print=pretty_print)
        if self.fidData is not None:
            self.fidData.export(outfile, level, namespace_, name_='fidData', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Acquisition1DType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.acquisitionParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionParameterSet=model_.AcquisitionParameterSet1DType(\n')
            self.acquisitionParameterSet.exportLiteral(outfile, level, name_='acquisitionParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fidData is not None:
            showIndent(outfile, level)
            outfile.write('fidData=model_.BinaryDataArrayType(\n')
            self.fidData.exportLiteral(outfile, level, name_='fidData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acquisitionParameterSet':
            obj_ = AcquisitionParameterSet1DType.factory()
            obj_.build(child_)
            self.acquisitionParameterSet = obj_
        elif nodeName_ == 'fidData':
            obj_ = BinaryDataArrayType.factory()
            obj_.build(child_)
            self.fidData = obj_
# end class Acquisition1DType


class AcquisitionMultiDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, acquisitionParameterSet=None, fidData=None):
        self.acquisitionParameterSet = acquisitionParameterSet
        self.fidData = fidData
    def factory(*args_, **kwargs_):
        if AcquisitionMultiDType.subclass:
            return AcquisitionMultiDType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionMultiDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acquisitionParameterSet(self): return self.acquisitionParameterSet
    def set_acquisitionParameterSet(self, acquisitionParameterSet): self.acquisitionParameterSet = acquisitionParameterSet
    def get_fidData(self): return self.fidData
    def set_fidData(self, fidData): self.fidData = fidData
    def hasContent_(self):
        if (
            self.acquisitionParameterSet is not None or
            self.fidData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AcquisitionMultiDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionMultiDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AcquisitionMultiDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AcquisitionMultiDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acquisitionParameterSet is not None:
            self.acquisitionParameterSet.export(outfile, level, namespace_, name_='acquisitionParameterSet', pretty_print=pretty_print)
        if self.fidData is not None:
            self.fidData.export(outfile, level, namespace_, name_='fidData', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcquisitionMultiDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.acquisitionParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionParameterSet=model_.AcquisitionParameterSetMultiDType(\n')
            self.acquisitionParameterSet.exportLiteral(outfile, level, name_='acquisitionParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fidData is not None:
            showIndent(outfile, level)
            outfile.write('fidData=model_.BinaryDataArrayType(\n')
            self.fidData.exportLiteral(outfile, level, name_='fidData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acquisitionParameterSet':
            obj_ = AcquisitionParameterSetMultiDType.factory()
            obj_.build(child_)
            self.acquisitionParameterSet = obj_
        elif nodeName_ == 'fidData':
            obj_ = BinaryDataArrayType.factory()
            obj_.build(child_)
            self.fidData = obj_
# end class AcquisitionMultiDType


class SpectrumListType(GeneratedsSuper):
    """List and descriptions of spectra.The number of spectra defined in
    this nmrML file.This attribute MUST reference the 'id' of the
    default data processing for the spectrum list. If an acquisition
    does not reference any data processing, it implicitly refers to
    this data processing. This attribute is required because the
    minimum amount of data processing that any format will undergo
    is "conversion to nmrML"."""
    subclass = None
    superclass = None
    def __init__(self, count=None, defaultDataProcessingRef=None, spectrum1D=None, spectrumMultiD=None):
        self.count = _cast(int, count)
        self.defaultDataProcessingRef = _cast(None, defaultDataProcessingRef)
        if spectrum1D is None:
            self.spectrum1D = []
        else:
            self.spectrum1D = spectrum1D
        if spectrumMultiD is None:
            self.spectrumMultiD = []
        else:
            self.spectrumMultiD = spectrumMultiD
    def factory(*args_, **kwargs_):
        if SpectrumListType.subclass:
            return SpectrumListType.subclass(*args_, **kwargs_)
        else:
            return SpectrumListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectrum1D(self): return self.spectrum1D
    def set_spectrum1D(self, spectrum1D): self.spectrum1D = spectrum1D
    def add_spectrum1D(self, value): self.spectrum1D.append(value)
    def insert_spectrum1D(self, index, value): self.spectrum1D[index] = value
    def get_spectrumMultiD(self): return self.spectrumMultiD
    def set_spectrumMultiD(self, spectrumMultiD): self.spectrumMultiD = spectrumMultiD
    def add_spectrumMultiD(self, value): self.spectrumMultiD.append(value)
    def insert_spectrumMultiD(self, index, value): self.spectrumMultiD[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_defaultDataProcessingRef(self): return self.defaultDataProcessingRef
    def set_defaultDataProcessingRef(self, defaultDataProcessingRef): self.defaultDataProcessingRef = defaultDataProcessingRef
    def hasContent_(self):
        if (
            self.spectrum1D or
            self.spectrumMultiD
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SpectrumListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectrumListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SpectrumListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.defaultDataProcessingRef is not None and 'defaultDataProcessingRef' not in already_processed:
            already_processed.add('defaultDataProcessingRef')
            outfile.write(' defaultDataProcessingRef=%s' % (self.gds_format_string(quote_attrib(self.defaultDataProcessingRef).encode(ExternalEncoding), input_name='defaultDataProcessingRef'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SpectrumListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for spectrum1D_ in self.spectrum1D:
            spectrum1D_.export(outfile, level, namespace_, name_='spectrum1D', pretty_print=pretty_print)
        for spectrumMultiD_ in self.spectrumMultiD:
            spectrumMultiD_.export(outfile, level, namespace_, name_='spectrumMultiD', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpectrumListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
        if self.defaultDataProcessingRef is not None and 'defaultDataProcessingRef' not in already_processed:
            already_processed.add('defaultDataProcessingRef')
            showIndent(outfile, level)
            outfile.write('defaultDataProcessingRef="%s",\n' % (self.defaultDataProcessingRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('spectrum1D=[\n')
        level += 1
        for spectrum1D_ in self.spectrum1D:
            showIndent(outfile, level)
            outfile.write('model_.Spectrum1DType(\n')
            spectrum1D_.exportLiteral(outfile, level, name_='Spectrum1DType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('spectrumMultiD=[\n')
        level += 1
        for spectrumMultiD_ in self.spectrumMultiD:
            showIndent(outfile, level)
            outfile.write('model_.SpectrumMultiDType(\n')
            spectrumMultiD_.exportLiteral(outfile, level, name_='SpectrumMultiDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('defaultDataProcessingRef', node)
        if value is not None and 'defaultDataProcessingRef' not in already_processed:
            already_processed.add('defaultDataProcessingRef')
            self.defaultDataProcessingRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spectrum1D':
            obj_ = Spectrum1DType.factory()
            obj_.build(child_)
            self.spectrum1D.append(obj_)
        elif nodeName_ == 'spectrumMultiD':
            obj_ = SpectrumMultiDType.factory()
            obj_.build(child_)
            self.spectrumMultiD.append(obj_)
# end class SpectrumListType


class SpectrumType(GeneratedsSuper):
    """A spectrum that is the result of processing the acquisition and a
    description of the process used to create it."""
    subclass = None
    superclass = None
    def __init__(self, numberOfDataPoints=None, processingSoftwareRefList=None, processingContactRefList=None, spectrumDataArray=None, xAxis=None, yAxisType=None, processingParameterSet=None, extensiontype_=None):
        self.numberOfDataPoints = _cast(int, numberOfDataPoints)
        if processingSoftwareRefList is None:
            self.processingSoftwareRefList = []
        else:
            self.processingSoftwareRefList = processingSoftwareRefList
        self.processingContactRefList = processingContactRefList
        self.spectrumDataArray = spectrumDataArray
        self.xAxis = xAxis
        self.yAxisType = yAxisType
        self.processingParameterSet = processingParameterSet
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SpectrumType.subclass:
            return SpectrumType.subclass(*args_, **kwargs_)
        else:
            return SpectrumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processingSoftwareRefList(self): return self.processingSoftwareRefList
    def set_processingSoftwareRefList(self, processingSoftwareRefList): self.processingSoftwareRefList = processingSoftwareRefList
    def add_processingSoftwareRefList(self, value): self.processingSoftwareRefList.append(value)
    def insert_processingSoftwareRefList(self, index, value): self.processingSoftwareRefList[index] = value
    def get_processingContactRefList(self): return self.processingContactRefList
    def set_processingContactRefList(self, processingContactRefList): self.processingContactRefList = processingContactRefList
    def get_spectrumDataArray(self): return self.spectrumDataArray
    def set_spectrumDataArray(self, spectrumDataArray): self.spectrumDataArray = spectrumDataArray
    def get_xAxis(self): return self.xAxis
    def set_xAxis(self, xAxis): self.xAxis = xAxis
    def get_yAxisType(self): return self.yAxisType
    def set_yAxisType(self, yAxisType): self.yAxisType = yAxisType
    def get_processingParameterSet(self): return self.processingParameterSet
    def set_processingParameterSet(self, processingParameterSet): self.processingParameterSet = processingParameterSet
    def get_numberOfDataPoints(self): return self.numberOfDataPoints
    def set_numberOfDataPoints(self, numberOfDataPoints): self.numberOfDataPoints = numberOfDataPoints
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.processingSoftwareRefList or
            self.processingContactRefList is not None or
            self.spectrumDataArray is not None or
            self.xAxis is not None or
            self.yAxisType is not None or
            self.processingParameterSet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SpectrumType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectrumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SpectrumType'):
        if self.numberOfDataPoints is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            outfile.write(' numberOfDataPoints="%s"' % self.gds_format_integer(self.numberOfDataPoints, input_name='numberOfDataPoints'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SpectrumType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for processingSoftwareRefList_ in self.processingSoftwareRefList:
            processingSoftwareRefList_.export(outfile, level, namespace_, name_='processingSoftwareRefList', pretty_print=pretty_print)
        if self.processingContactRefList is not None:
            self.processingContactRefList.export(outfile, level, namespace_, name_='processingContactRefList', pretty_print=pretty_print)
        if self.spectrumDataArray is not None:
            self.spectrumDataArray.export(outfile, level, namespace_, name_='spectrumDataArray', pretty_print=pretty_print)
        if self.xAxis is not None:
            self.xAxis.export(outfile, level, namespace_, name_='xAxis', pretty_print=pretty_print)
        if self.yAxisType is not None:
            self.yAxisType.export(outfile, level, namespace_, name_='yAxisType', pretty_print=pretty_print)
        if self.processingParameterSet is not None:
            self.processingParameterSet.export(outfile, level, namespace_, name_='processingParameterSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpectrumType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfDataPoints is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            showIndent(outfile, level)
            outfile.write('numberOfDataPoints=%d,\n' % (self.numberOfDataPoints,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('processingSoftwareRefList=[\n')
        level += 1
        for processingSoftwareRefList_ in self.processingSoftwareRefList:
            showIndent(outfile, level)
            outfile.write('model_.SoftwareRefListType(\n')
            processingSoftwareRefList_.exportLiteral(outfile, level, name_='SoftwareRefListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.processingContactRefList is not None:
            showIndent(outfile, level)
            outfile.write('processingContactRefList=model_.ContactRefListType(\n')
            self.processingContactRefList.exportLiteral(outfile, level, name_='processingContactRefList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spectrumDataArray is not None:
            showIndent(outfile, level)
            outfile.write('spectrumDataArray=model_.BinaryDataArrayType(\n')
            self.spectrumDataArray.exportLiteral(outfile, level, name_='spectrumDataArray')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.xAxis is not None:
            showIndent(outfile, level)
            outfile.write('xAxis=model_.AxisWithUnitType(\n')
            self.xAxis.exportLiteral(outfile, level, name_='xAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.yAxisType is not None:
            showIndent(outfile, level)
            outfile.write('yAxisType=model_.CVTermType(\n')
            self.yAxisType.exportLiteral(outfile, level, name_='yAxisType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.processingParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('processingParameterSet=model_.processingParameterSetType(\n')
            self.processingParameterSet.exportLiteral(outfile, level, name_='processingParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfDataPoints', node)
        if value is not None and 'numberOfDataPoints' not in already_processed:
            already_processed.add('numberOfDataPoints')
            try:
                self.numberOfDataPoints = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processingSoftwareRefList':
            obj_ = SoftwareRefListType.factory()
            obj_.build(child_)
            self.processingSoftwareRefList.append(obj_)
        elif nodeName_ == 'processingContactRefList':
            obj_ = ContactRefListType.factory()
            obj_.build(child_)
            self.processingContactRefList = obj_
        elif nodeName_ == 'spectrumDataArray':
            obj_ = BinaryDataArrayType.factory()
            obj_.build(child_)
            self.spectrumDataArray = obj_
        elif nodeName_ == 'xAxis':
            obj_ = AxisWithUnitType.factory()
            obj_.build(child_)
            self.xAxis = obj_
        elif nodeName_ == 'yAxisType':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.yAxisType = obj_
        elif nodeName_ == 'processingParameterSet':
            obj_ = processingParameterSetType.factory()
            obj_.build(child_)
            self.processingParameterSet = obj_
# end class SpectrumType


class Spectrum1DType(SpectrumType):
    subclass = None
    superclass = SpectrumType
    def __init__(self, numberOfDataPoints=None, processingSoftwareRefList=None, processingContactRefList=None, spectrumDataArray=None, xAxis=None, yAxisType=None, processingParameterSet=None, firstDimensionProcessingParameterSet=None):
        super(Spectrum1DType, self).__init__(numberOfDataPoints, processingSoftwareRefList, processingContactRefList, spectrumDataArray, xAxis, yAxisType, processingParameterSet, )
        self.firstDimensionProcessingParameterSet = firstDimensionProcessingParameterSet
    def factory(*args_, **kwargs_):
        if Spectrum1DType.subclass:
            return Spectrum1DType.subclass(*args_, **kwargs_)
        else:
            return Spectrum1DType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstDimensionProcessingParameterSet(self): return self.firstDimensionProcessingParameterSet
    def set_firstDimensionProcessingParameterSet(self, firstDimensionProcessingParameterSet): self.firstDimensionProcessingParameterSet = firstDimensionProcessingParameterSet
    def hasContent_(self):
        if (
            self.firstDimensionProcessingParameterSet is not None or
            super(Spectrum1DType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='Spectrum1DType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Spectrum1DType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='Spectrum1DType'):
        super(Spectrum1DType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Spectrum1DType')
    def exportChildren(self, outfile, level, namespace_='dx:', name_='Spectrum1DType', fromsubclass_=False, pretty_print=True):
        super(Spectrum1DType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firstDimensionProcessingParameterSet is not None:
            self.firstDimensionProcessingParameterSet.export(outfile, level, namespace_, name_='firstDimensionProcessingParameterSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Spectrum1DType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Spectrum1DType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Spectrum1DType, self).exportLiteralChildren(outfile, level, name_)
        if self.firstDimensionProcessingParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('firstDimensionProcessingParameterSet=model_.FirstDimensionProcessingParameterSetType(\n')
            self.firstDimensionProcessingParameterSet.exportLiteral(outfile, level, name_='firstDimensionProcessingParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Spectrum1DType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firstDimensionProcessingParameterSet':
            class_obj_ = self.get_class_obj_(child_, FirstDimensionProcessingParameterSetType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.firstDimensionProcessingParameterSet = obj_
        super(Spectrum1DType, self).buildChildren(child_, node, nodeName_, True)
# end class Spectrum1DType


class SpectrumMultiDType(SpectrumType):
    subclass = None
    superclass = SpectrumType
    def __init__(self, numberOfDataPoints=None, processingSoftwareRefList=None, processingContactRefList=None, spectrumDataArray=None, xAxis=None, yAxisType=None, processingParameterSet=None, firstDimensionProcessingParameterSet=None, higherDimensionProcessingParameterSet=None, projected3DProcessingParamaterSet=None):
        super(SpectrumMultiDType, self).__init__(numberOfDataPoints, processingSoftwareRefList, processingContactRefList, spectrumDataArray, xAxis, yAxisType, processingParameterSet, )
        self.firstDimensionProcessingParameterSet = firstDimensionProcessingParameterSet
        if higherDimensionProcessingParameterSet is None:
            self.higherDimensionProcessingParameterSet = []
        else:
            self.higherDimensionProcessingParameterSet = higherDimensionProcessingParameterSet
        self.projected3DProcessingParamaterSet = projected3DProcessingParamaterSet
    def factory(*args_, **kwargs_):
        if SpectrumMultiDType.subclass:
            return SpectrumMultiDType.subclass(*args_, **kwargs_)
        else:
            return SpectrumMultiDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstDimensionProcessingParameterSet(self): return self.firstDimensionProcessingParameterSet
    def set_firstDimensionProcessingParameterSet(self, firstDimensionProcessingParameterSet): self.firstDimensionProcessingParameterSet = firstDimensionProcessingParameterSet
    def get_higherDimensionProcessingParameterSet(self): return self.higherDimensionProcessingParameterSet
    def set_higherDimensionProcessingParameterSet(self, higherDimensionProcessingParameterSet): self.higherDimensionProcessingParameterSet = higherDimensionProcessingParameterSet
    def add_higherDimensionProcessingParameterSet(self, value): self.higherDimensionProcessingParameterSet.append(value)
    def insert_higherDimensionProcessingParameterSet(self, index, value): self.higherDimensionProcessingParameterSet[index] = value
    def get_projected3DProcessingParamaterSet(self): return self.projected3DProcessingParamaterSet
    def set_projected3DProcessingParamaterSet(self, projected3DProcessingParamaterSet): self.projected3DProcessingParamaterSet = projected3DProcessingParamaterSet
    def hasContent_(self):
        if (
            self.firstDimensionProcessingParameterSet is not None or
            self.higherDimensionProcessingParameterSet or
            self.projected3DProcessingParamaterSet is not None or
            super(SpectrumMultiDType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SpectrumMultiDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectrumMultiDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SpectrumMultiDType'):
        super(SpectrumMultiDType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpectrumMultiDType')
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SpectrumMultiDType', fromsubclass_=False, pretty_print=True):
        super(SpectrumMultiDType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firstDimensionProcessingParameterSet is not None:
            self.firstDimensionProcessingParameterSet.export(outfile, level, namespace_, name_='firstDimensionProcessingParameterSet', pretty_print=pretty_print)
        for higherDimensionProcessingParameterSet_ in self.higherDimensionProcessingParameterSet:
            higherDimensionProcessingParameterSet_.export(outfile, level, namespace_, name_='higherDimensionProcessingParameterSet', pretty_print=pretty_print)
        if self.projected3DProcessingParamaterSet is not None:
            self.projected3DProcessingParamaterSet.export(outfile, level, namespace_, name_='projected3DProcessingParamaterSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpectrumMultiDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SpectrumMultiDType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SpectrumMultiDType, self).exportLiteralChildren(outfile, level, name_)
        if self.firstDimensionProcessingParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('firstDimensionProcessingParameterSet=model_.FirstDimensionProcessingParameterSetType(\n')
            self.firstDimensionProcessingParameterSet.exportLiteral(outfile, level, name_='firstDimensionProcessingParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('higherDimensionProcessingParameterSet=[\n')
        level += 1
        for higherDimensionProcessingParameterSet_ in self.higherDimensionProcessingParameterSet:
            showIndent(outfile, level)
            outfile.write('model_.HigherDimensionProcessingParameterSetType(\n')
            higherDimensionProcessingParameterSet_.exportLiteral(outfile, level, name_='HigherDimensionProcessingParameterSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.projected3DProcessingParamaterSet is not None:
            showIndent(outfile, level)
            outfile.write('projected3DProcessingParamaterSet=model_.Projected3DProcessingParamaterSetType(\n')
            self.projected3DProcessingParamaterSet.exportLiteral(outfile, level, name_='projected3DProcessingParamaterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SpectrumMultiDType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firstDimensionProcessingParameterSet':
            class_obj_ = self.get_class_obj_(child_, FirstDimensionProcessingParameterSetType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.firstDimensionProcessingParameterSet = obj_
        elif nodeName_ == 'higherDimensionProcessingParameterSet':
            obj_ = HigherDimensionProcessingParameterSetType.factory()
            obj_.build(child_)
            self.higherDimensionProcessingParameterSet.append(obj_)
        elif nodeName_ == 'projected3DProcessingParamaterSet':
            obj_ = Projected3DProcessingParamaterSetType.factory()
            obj_.build(child_)
            self.projected3DProcessingParamaterSet = obj_
        super(SpectrumMultiDType, self).buildChildren(child_, node, nodeName_, True)
# end class SpectrumMultiDType


class SpectralProcessingParameterSetType(GeneratedsSuper):
    """Parameters recorded when raw data set is processed to create a
    spectra."""
    subclass = None
    superclass = None
    def __init__(self, processingSoftwareRefList=None, postAcquisitionSolventSuppressionMethod=None, dataTransformationMethod=None, calibrationCompound=None, extensiontype_=None):
        if processingSoftwareRefList is None:
            self.processingSoftwareRefList = []
        else:
            self.processingSoftwareRefList = processingSoftwareRefList
        self.postAcquisitionSolventSuppressionMethod = postAcquisitionSolventSuppressionMethod
        self.dataTransformationMethod = dataTransformationMethod
        self.calibrationCompound = calibrationCompound
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SpectralProcessingParameterSetType.subclass:
            return SpectralProcessingParameterSetType.subclass(*args_, **kwargs_)
        else:
            return SpectralProcessingParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processingSoftwareRefList(self): return self.processingSoftwareRefList
    def set_processingSoftwareRefList(self, processingSoftwareRefList): self.processingSoftwareRefList = processingSoftwareRefList
    def add_processingSoftwareRefList(self, value): self.processingSoftwareRefList.append(value)
    def insert_processingSoftwareRefList(self, index, value): self.processingSoftwareRefList[index] = value
    def get_postAcquisitionSolventSuppressionMethod(self): return self.postAcquisitionSolventSuppressionMethod
    def set_postAcquisitionSolventSuppressionMethod(self, postAcquisitionSolventSuppressionMethod): self.postAcquisitionSolventSuppressionMethod = postAcquisitionSolventSuppressionMethod
    def get_dataTransformationMethod(self): return self.dataTransformationMethod
    def set_dataTransformationMethod(self, dataTransformationMethod): self.dataTransformationMethod = dataTransformationMethod
    def get_calibrationCompound(self): return self.calibrationCompound
    def set_calibrationCompound(self, calibrationCompound): self.calibrationCompound = calibrationCompound
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.processingSoftwareRefList or
            self.postAcquisitionSolventSuppressionMethod is not None or
            self.dataTransformationMethod is not None or
            self.calibrationCompound is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SpectralProcessingParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralProcessingParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SpectralProcessingParameterSetType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SpectralProcessingParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for processingSoftwareRefList_ in self.processingSoftwareRefList:
            processingSoftwareRefList_.export(outfile, level, namespace_, name_='processingSoftwareRefList', pretty_print=pretty_print)
        if self.postAcquisitionSolventSuppressionMethod is not None:
            self.postAcquisitionSolventSuppressionMethod.export(outfile, level, namespace_, name_='postAcquisitionSolventSuppressionMethod', pretty_print=pretty_print)
        if self.dataTransformationMethod is not None:
            self.dataTransformationMethod.export(outfile, level, namespace_, name_='dataTransformationMethod', pretty_print=pretty_print)
        if self.calibrationCompound is not None:
            self.calibrationCompound.export(outfile, level, namespace_, name_='calibrationCompound', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpectralProcessingParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('processingSoftwareRefList=[\n')
        level += 1
        for processingSoftwareRefList_ in self.processingSoftwareRefList:
            showIndent(outfile, level)
            outfile.write('model_.SoftwareRefListType(\n')
            processingSoftwareRefList_.exportLiteral(outfile, level, name_='SoftwareRefListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.postAcquisitionSolventSuppressionMethod is not None:
            showIndent(outfile, level)
            outfile.write('postAcquisitionSolventSuppressionMethod=model_.CVTermType(\n')
            self.postAcquisitionSolventSuppressionMethod.exportLiteral(outfile, level, name_='postAcquisitionSolventSuppressionMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataTransformationMethod is not None:
            showIndent(outfile, level)
            outfile.write('dataTransformationMethod=model_.CVTermType(\n')
            self.dataTransformationMethod.exportLiteral(outfile, level, name_='dataTransformationMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calibrationCompound is not None:
            showIndent(outfile, level)
            outfile.write('calibrationCompound=model_.CVTermType(\n')
            self.calibrationCompound.exportLiteral(outfile, level, name_='calibrationCompound')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processingSoftwareRefList':
            obj_ = SoftwareRefListType.factory()
            obj_.build(child_)
            self.processingSoftwareRefList.append(obj_)
        elif nodeName_ == 'postAcquisitionSolventSuppressionMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.postAcquisitionSolventSuppressionMethod = obj_
        elif nodeName_ == 'dataTransformationMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.dataTransformationMethod = obj_
        elif nodeName_ == 'calibrationCompound':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.calibrationCompound = obj_
# end class SpectralProcessingParameterSetType


class SpectralProjectionParameterSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, projectionAxis=None, projectionMethod=None):
        self.projectionAxis = _cast(None, projectionAxis)
        self.projectionMethod = projectionMethod
    def factory(*args_, **kwargs_):
        if SpectralProjectionParameterSetType.subclass:
            return SpectralProjectionParameterSetType.subclass(*args_, **kwargs_)
        else:
            return SpectralProjectionParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_projectionMethod(self): return self.projectionMethod
    def set_projectionMethod(self, projectionMethod): self.projectionMethod = projectionMethod
    def get_projectionAxis(self): return self.projectionAxis
    def set_projectionAxis(self, projectionAxis): self.projectionAxis = projectionAxis
    def hasContent_(self):
        if (
            self.projectionMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SpectralProjectionParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralProjectionParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SpectralProjectionParameterSetType'):
        if self.projectionAxis is not None and 'projectionAxis' not in already_processed:
            already_processed.add('projectionAxis')
            outfile.write(' projectionAxis=%s' % (self.gds_format_string(quote_attrib(self.projectionAxis).encode(ExternalEncoding), input_name='projectionAxis'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SpectralProjectionParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.projectionMethod is not None:
            self.projectionMethod.export(outfile, level, namespace_, name_='projectionMethod', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpectralProjectionParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.projectionAxis is not None and 'projectionAxis' not in already_processed:
            already_processed.add('projectionAxis')
            showIndent(outfile, level)
            outfile.write('projectionAxis="%s",\n' % (self.projectionAxis,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.projectionMethod is not None:
            showIndent(outfile, level)
            outfile.write('projectionMethod=model_.CVTermType(\n')
            self.projectionMethod.exportLiteral(outfile, level, name_='projectionMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('projectionAxis', node)
        if value is not None and 'projectionAxis' not in already_processed:
            already_processed.add('projectionAxis')
            self.projectionAxis = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'projectionMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.projectionMethod = obj_
# end class SpectralProjectionParameterSetType


class SpectralProcessingParameterSet2DType(SpectralProcessingParameterSetType):
    """Parameters recorded when raw data set is processed to create a 2D
    spectra."""
    subclass = None
    superclass = SpectralProcessingParameterSetType
    def __init__(self, processingSoftwareRefList=None, postAcquisitionSolventSuppressionMethod=None, dataTransformationMethod=None, calibrationCompound=None, directDimensionParameterSet=None, higherDimensionParameterSet=None):
        super(SpectralProcessingParameterSet2DType, self).__init__(processingSoftwareRefList, postAcquisitionSolventSuppressionMethod, dataTransformationMethod, calibrationCompound, )
        self.directDimensionParameterSet = directDimensionParameterSet
        if higherDimensionParameterSet is None:
            self.higherDimensionParameterSet = []
        else:
            self.higherDimensionParameterSet = higherDimensionParameterSet
    def factory(*args_, **kwargs_):
        if SpectralProcessingParameterSet2DType.subclass:
            return SpectralProcessingParameterSet2DType.subclass(*args_, **kwargs_)
        else:
            return SpectralProcessingParameterSet2DType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directDimensionParameterSet(self): return self.directDimensionParameterSet
    def set_directDimensionParameterSet(self, directDimensionParameterSet): self.directDimensionParameterSet = directDimensionParameterSet
    def get_higherDimensionParameterSet(self): return self.higherDimensionParameterSet
    def set_higherDimensionParameterSet(self, higherDimensionParameterSet): self.higherDimensionParameterSet = higherDimensionParameterSet
    def add_higherDimensionParameterSet(self, value): self.higherDimensionParameterSet.append(value)
    def insert_higherDimensionParameterSet(self, index, value): self.higherDimensionParameterSet[index] = value
    def hasContent_(self):
        if (
            self.directDimensionParameterSet is not None or
            self.higherDimensionParameterSet or
            super(SpectralProcessingParameterSet2DType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='SpectralProcessingParameterSet2DType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralProcessingParameterSet2DType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='SpectralProcessingParameterSet2DType'):
        super(SpectralProcessingParameterSet2DType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralProcessingParameterSet2DType')
    def exportChildren(self, outfile, level, namespace_='dx:', name_='SpectralProcessingParameterSet2DType', fromsubclass_=False, pretty_print=True):
        super(SpectralProcessingParameterSet2DType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.directDimensionParameterSet is not None:
            self.directDimensionParameterSet.export(outfile, level, namespace_, name_='directDimensionParameterSet', pretty_print=pretty_print)
        for higherDimensionParameterSet_ in self.higherDimensionParameterSet:
            higherDimensionParameterSet_.export(outfile, level, namespace_, name_='higherDimensionParameterSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpectralProcessingParameterSet2DType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SpectralProcessingParameterSet2DType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SpectralProcessingParameterSet2DType, self).exportLiteralChildren(outfile, level, name_)
        if self.directDimensionParameterSet is not None:
            showIndent(outfile, level)
            outfile.write('directDimensionParameterSet=model_.FirstDimensionProcessingParameterSetType(\n')
            self.directDimensionParameterSet.exportLiteral(outfile, level, name_='directDimensionParameterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('higherDimensionParameterSet=[\n')
        level += 1
        for higherDimensionParameterSet_ in self.higherDimensionParameterSet:
            showIndent(outfile, level)
            outfile.write('model_.HigherDimensionProcessingParameterSetType(\n')
            higherDimensionParameterSet_.exportLiteral(outfile, level, name_='HigherDimensionProcessingParameterSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SpectralProcessingParameterSet2DType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'directDimensionParameterSet':
            class_obj_ = self.get_class_obj_(child_, FirstDimensionProcessingParameterSetType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.directDimensionParameterSet = obj_
        elif nodeName_ == 'higherDimensionParameterSet':
            obj_ = HigherDimensionProcessingParameterSetType.factory()
            obj_.build(child_)
            self.higherDimensionParameterSet.append(obj_)
        super(SpectralProcessingParameterSet2DType, self).buildChildren(child_, node, nodeName_, True)
# end class SpectralProcessingParameterSet2DType


class FirstDimensionProcessingParameterSetType(GeneratedsSuper):
    """Parameters recorded when raw data set is processed to create a
    spectra that are specific to a dimension.This number will also
    reflect the zero filling."""
    subclass = None
    superclass = None
    def __init__(self, noOfDataPoints=None, zeroOrderPhaseCorrection=None, firstOrderPhaseCorrection=None, calibrationReferenceShift=None, spectralDenoisingMethod=None, windowFunction=None, baselineCorrectionMethod=None, parameterFileRef=None, extensiontype_=None):
        self.noOfDataPoints = _cast(int, noOfDataPoints)
        self.zeroOrderPhaseCorrection = zeroOrderPhaseCorrection
        self.firstOrderPhaseCorrection = firstOrderPhaseCorrection
        self.calibrationReferenceShift = calibrationReferenceShift
        self.spectralDenoisingMethod = spectralDenoisingMethod
        if windowFunction is None:
            self.windowFunction = []
        else:
            self.windowFunction = windowFunction
        self.baselineCorrectionMethod = baselineCorrectionMethod
        self.parameterFileRef = parameterFileRef
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if FirstDimensionProcessingParameterSetType.subclass:
            return FirstDimensionProcessingParameterSetType.subclass(*args_, **kwargs_)
        else:
            return FirstDimensionProcessingParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zeroOrderPhaseCorrection(self): return self.zeroOrderPhaseCorrection
    def set_zeroOrderPhaseCorrection(self, zeroOrderPhaseCorrection): self.zeroOrderPhaseCorrection = zeroOrderPhaseCorrection
    def get_firstOrderPhaseCorrection(self): return self.firstOrderPhaseCorrection
    def set_firstOrderPhaseCorrection(self, firstOrderPhaseCorrection): self.firstOrderPhaseCorrection = firstOrderPhaseCorrection
    def get_calibrationReferenceShift(self): return self.calibrationReferenceShift
    def set_calibrationReferenceShift(self, calibrationReferenceShift): self.calibrationReferenceShift = calibrationReferenceShift
    def get_spectralDenoisingMethod(self): return self.spectralDenoisingMethod
    def set_spectralDenoisingMethod(self, spectralDenoisingMethod): self.spectralDenoisingMethod = spectralDenoisingMethod
    def get_windowFunction(self): return self.windowFunction
    def set_windowFunction(self, windowFunction): self.windowFunction = windowFunction
    def add_windowFunction(self, value): self.windowFunction.append(value)
    def insert_windowFunction(self, index, value): self.windowFunction[index] = value
    def get_baselineCorrectionMethod(self): return self.baselineCorrectionMethod
    def set_baselineCorrectionMethod(self, baselineCorrectionMethod): self.baselineCorrectionMethod = baselineCorrectionMethod
    def get_parameterFileRef(self): return self.parameterFileRef
    def set_parameterFileRef(self, parameterFileRef): self.parameterFileRef = parameterFileRef
    def get_noOfDataPoints(self): return self.noOfDataPoints
    def set_noOfDataPoints(self, noOfDataPoints): self.noOfDataPoints = noOfDataPoints
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.zeroOrderPhaseCorrection is not None or
            self.firstOrderPhaseCorrection is not None or
            self.calibrationReferenceShift is not None or
            self.spectralDenoisingMethod is not None or
            self.windowFunction or
            self.baselineCorrectionMethod is not None or
            self.parameterFileRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='FirstDimensionProcessingParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstDimensionProcessingParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='FirstDimensionProcessingParameterSetType'):
        if self.noOfDataPoints is not None and 'noOfDataPoints' not in already_processed:
            already_processed.add('noOfDataPoints')
            outfile.write(' noOfDataPoints="%s"' % self.gds_format_integer(self.noOfDataPoints, input_name='noOfDataPoints'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='dx:', name_='FirstDimensionProcessingParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.zeroOrderPhaseCorrection is not None:
            self.zeroOrderPhaseCorrection.export(outfile, level, namespace_, name_='zeroOrderPhaseCorrection', pretty_print=pretty_print)
        if self.firstOrderPhaseCorrection is not None:
            self.firstOrderPhaseCorrection.export(outfile, level, namespace_, name_='firstOrderPhaseCorrection', pretty_print=pretty_print)
        if self.calibrationReferenceShift is not None:
            self.calibrationReferenceShift.export(outfile, level, namespace_, name_='calibrationReferenceShift', pretty_print=pretty_print)
        if self.spectralDenoisingMethod is not None:
            self.spectralDenoisingMethod.export(outfile, level, namespace_, name_='spectralDenoisingMethod', pretty_print=pretty_print)
        for windowFunction_ in self.windowFunction:
            windowFunction_.export(outfile, level, namespace_, name_='windowFunction', pretty_print=pretty_print)
        if self.baselineCorrectionMethod is not None:
            self.baselineCorrectionMethod.export(outfile, level, namespace_, name_='baselineCorrectionMethod', pretty_print=pretty_print)
        if self.parameterFileRef is not None:
            self.parameterFileRef.export(outfile, level, namespace_, name_='parameterFileRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirstDimensionProcessingParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.noOfDataPoints is not None and 'noOfDataPoints' not in already_processed:
            already_processed.add('noOfDataPoints')
            showIndent(outfile, level)
            outfile.write('noOfDataPoints=%d,\n' % (self.noOfDataPoints,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.zeroOrderPhaseCorrection is not None:
            showIndent(outfile, level)
            outfile.write('zeroOrderPhaseCorrection=model_.ValueWithUnitType(\n')
            self.zeroOrderPhaseCorrection.exportLiteral(outfile, level, name_='zeroOrderPhaseCorrection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.firstOrderPhaseCorrection is not None:
            showIndent(outfile, level)
            outfile.write('firstOrderPhaseCorrection=model_.ValueWithUnitType(\n')
            self.firstOrderPhaseCorrection.exportLiteral(outfile, level, name_='firstOrderPhaseCorrection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calibrationReferenceShift is not None:
            showIndent(outfile, level)
            outfile.write('calibrationReferenceShift=model_.ValueWithUnitType(\n')
            self.calibrationReferenceShift.exportLiteral(outfile, level, name_='calibrationReferenceShift')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spectralDenoisingMethod is not None:
            showIndent(outfile, level)
            outfile.write('spectralDenoisingMethod=model_.CVTermType(\n')
            self.spectralDenoisingMethod.exportLiteral(outfile, level, name_='spectralDenoisingMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('windowFunction=[\n')
        level += 1
        for windowFunction_ in self.windowFunction:
            showIndent(outfile, level)
            outfile.write('model_.windowFunctionType(\n')
            windowFunction_.exportLiteral(outfile, level, name_='windowFunctionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.baselineCorrectionMethod is not None:
            showIndent(outfile, level)
            outfile.write('baselineCorrectionMethod=model_.CVTermType(\n')
            self.baselineCorrectionMethod.exportLiteral(outfile, level, name_='baselineCorrectionMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parameterFileRef is not None:
            showIndent(outfile, level)
            outfile.write('parameterFileRef=model_.SourceFileRefType(\n')
            self.parameterFileRef.exportLiteral(outfile, level, name_='parameterFileRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('noOfDataPoints', node)
        if value is not None and 'noOfDataPoints' not in already_processed:
            already_processed.add('noOfDataPoints')
            try:
                self.noOfDataPoints = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'zeroOrderPhaseCorrection':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.zeroOrderPhaseCorrection = obj_
        elif nodeName_ == 'firstOrderPhaseCorrection':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.firstOrderPhaseCorrection = obj_
        elif nodeName_ == 'calibrationReferenceShift':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.calibrationReferenceShift = obj_
        elif nodeName_ == 'spectralDenoisingMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.spectralDenoisingMethod = obj_
        elif nodeName_ == 'windowFunction':
            obj_ = windowFunctionType.factory()
            obj_.build(child_)
            self.windowFunction.append(obj_)
        elif nodeName_ == 'baselineCorrectionMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baselineCorrectionMethod = obj_
        elif nodeName_ == 'parameterFileRef':
            obj_ = SourceFileRefType.factory()
            obj_.build(child_)
            self.parameterFileRef = obj_
# end class FirstDimensionProcessingParameterSetType


class AxisWithUnitType(GeneratedsSuper):
    """An optional CV accession number for the unit term associated with
    the value, if any (e.g., 'UO:0000266' for 'electron volt').An
    optional CV name for the unit accession number, if any (e.g.,
    'electron volt' for 'UO:0000266' ).If a unit term is referenced,
    this attribute must refer to the CV 'id' attribute defined in
    the cvList in this nmrML file."""
    subclass = None
    superclass = None
    def __init__(self, endValue=None, unitName=None, unitCvRef=None, startValue=None, unitAccession=None):
        self.endValue = _cast(None, endValue)
        self.unitName = _cast(None, unitName)
        self.unitCvRef = _cast(None, unitCvRef)
        self.startValue = _cast(None, startValue)
        self.unitAccession = _cast(None, unitAccession)
        pass
    def factory(*args_, **kwargs_):
        if AxisWithUnitType.subclass:
            return AxisWithUnitType.subclass(*args_, **kwargs_)
        else:
            return AxisWithUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_endValue(self): return self.endValue
    def set_endValue(self, endValue): self.endValue = endValue
    def get_unitName(self): return self.unitName
    def set_unitName(self, unitName): self.unitName = unitName
    def get_unitCvRef(self): return self.unitCvRef
    def set_unitCvRef(self, unitCvRef): self.unitCvRef = unitCvRef
    def get_startValue(self): return self.startValue
    def set_startValue(self, startValue): self.startValue = startValue
    def get_unitAccession(self): return self.unitAccession
    def set_unitAccession(self, unitAccession): self.unitAccession = unitAccession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='AxisWithUnitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AxisWithUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='AxisWithUnitType'):
        if self.endValue is not None and 'endValue' not in already_processed:
            already_processed.add('endValue')
            outfile.write(' endValue=%s' % (self.gds_format_string(quote_attrib(self.endValue).encode(ExternalEncoding), input_name='endValue'), ))
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            outfile.write(' unitName=%s' % (self.gds_format_string(quote_attrib(self.unitName).encode(ExternalEncoding), input_name='unitName'), ))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            outfile.write(' unitCvRef=%s' % (self.gds_format_string(quote_attrib(self.unitCvRef).encode(ExternalEncoding), input_name='unitCvRef'), ))
        if self.startValue is not None and 'startValue' not in already_processed:
            already_processed.add('startValue')
            outfile.write(' startValue=%s' % (self.gds_format_string(quote_attrib(self.startValue).encode(ExternalEncoding), input_name='startValue'), ))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            outfile.write(' unitAccession=%s' % (self.gds_format_string(quote_attrib(self.unitAccession).encode(ExternalEncoding), input_name='unitAccession'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='AxisWithUnitType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AxisWithUnitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.endValue is not None and 'endValue' not in already_processed:
            already_processed.add('endValue')
            showIndent(outfile, level)
            outfile.write('endValue="%s",\n' % (self.endValue,))
        if self.unitName is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            showIndent(outfile, level)
            outfile.write('unitName="%s",\n' % (self.unitName,))
        if self.unitCvRef is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            showIndent(outfile, level)
            outfile.write('unitCvRef="%s",\n' % (self.unitCvRef,))
        if self.startValue is not None and 'startValue' not in already_processed:
            already_processed.add('startValue')
            showIndent(outfile, level)
            outfile.write('startValue="%s",\n' % (self.startValue,))
        if self.unitAccession is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            showIndent(outfile, level)
            outfile.write('unitAccession="%s",\n' % (self.unitAccession,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('endValue', node)
        if value is not None and 'endValue' not in already_processed:
            already_processed.add('endValue')
            self.endValue = value
        value = find_attr_value_('unitName', node)
        if value is not None and 'unitName' not in already_processed:
            already_processed.add('unitName')
            self.unitName = value
        value = find_attr_value_('unitCvRef', node)
        if value is not None and 'unitCvRef' not in already_processed:
            already_processed.add('unitCvRef')
            self.unitCvRef = value
        value = find_attr_value_('startValue', node)
        if value is not None and 'startValue' not in already_processed:
            already_processed.add('startValue')
            self.startValue = value
        value = find_attr_value_('unitAccession', node)
        if value is not None and 'unitAccession' not in already_processed:
            already_processed.add('unitAccession')
            self.unitAccession = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AxisWithUnitType


class HigherDimensionProcessingParameterSetType(FirstDimensionProcessingParameterSetType):
    """Parameters recorded when raw data set is processed to create a
    spectra that are specific to the second dimension."""
    subclass = None
    superclass = FirstDimensionProcessingParameterSetType
    def __init__(self, noOfDataPoints=None, zeroOrderPhaseCorrection=None, firstOrderPhaseCorrection=None, calibrationReferenceShift=None, spectralDenoisingMethod=None, windowFunction=None, baselineCorrectionMethod=None, parameterFileRef=None):
        super(HigherDimensionProcessingParameterSetType, self).__init__(noOfDataPoints, zeroOrderPhaseCorrection, firstOrderPhaseCorrection, calibrationReferenceShift, spectralDenoisingMethod, windowFunction, baselineCorrectionMethod, parameterFileRef, )
        pass
    def factory(*args_, **kwargs_):
        if HigherDimensionProcessingParameterSetType.subclass:
            return HigherDimensionProcessingParameterSetType.subclass(*args_, **kwargs_)
        else:
            return HigherDimensionProcessingParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(HigherDimensionProcessingParameterSetType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='HigherDimensionProcessingParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HigherDimensionProcessingParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='HigherDimensionProcessingParameterSetType'):
        super(HigherDimensionProcessingParameterSetType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HigherDimensionProcessingParameterSetType')
    def exportChildren(self, outfile, level, namespace_='dx:', name_='HigherDimensionProcessingParameterSetType', fromsubclass_=False, pretty_print=True):
        super(HigherDimensionProcessingParameterSetType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HigherDimensionProcessingParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HigherDimensionProcessingParameterSetType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HigherDimensionProcessingParameterSetType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(HigherDimensionProcessingParameterSetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HigherDimensionProcessingParameterSetType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HigherDimensionProcessingParameterSetType


class Projected3DProcessingParamaterSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, positiveProjectionMethod=None, projectionAngle=None):
        self.positiveProjectionMethod = _cast(bool, positiveProjectionMethod)
        self.projectionAngle = _cast(float, projectionAngle)
        pass
    def factory(*args_, **kwargs_):
        if Projected3DProcessingParamaterSetType.subclass:
            return Projected3DProcessingParamaterSetType.subclass(*args_, **kwargs_)
        else:
            return Projected3DProcessingParamaterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_positiveProjectionMethod(self): return self.positiveProjectionMethod
    def set_positiveProjectionMethod(self, positiveProjectionMethod): self.positiveProjectionMethod = positiveProjectionMethod
    def get_projectionAngle(self): return self.projectionAngle
    def set_projectionAngle(self, projectionAngle): self.projectionAngle = projectionAngle
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='Projected3DProcessingParamaterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Projected3DProcessingParamaterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='Projected3DProcessingParamaterSetType'):
        if self.positiveProjectionMethod is not None and 'positiveProjectionMethod' not in already_processed:
            already_processed.add('positiveProjectionMethod')
            outfile.write(' positiveProjectionMethod="%s"' % self.gds_format_boolean(self.positiveProjectionMethod, input_name='positiveProjectionMethod'))
        if self.projectionAngle is not None and 'projectionAngle' not in already_processed:
            already_processed.add('projectionAngle')
            outfile.write(' projectionAngle="%s"' % self.gds_format_double(self.projectionAngle, input_name='projectionAngle'))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='Projected3DProcessingParamaterSetType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Projected3DProcessingParamaterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.positiveProjectionMethod is not None and 'positiveProjectionMethod' not in already_processed:
            already_processed.add('positiveProjectionMethod')
            showIndent(outfile, level)
            outfile.write('positiveProjectionMethod=%s,\n' % (self.positiveProjectionMethod,))
        if self.projectionAngle is not None and 'projectionAngle' not in already_processed:
            already_processed.add('projectionAngle')
            showIndent(outfile, level)
            outfile.write('projectionAngle=%e,\n' % (self.projectionAngle,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positiveProjectionMethod', node)
        if value is not None and 'positiveProjectionMethod' not in already_processed:
            already_processed.add('positiveProjectionMethod')
            if value in ('true', '1'):
                self.positiveProjectionMethod = True
            elif value in ('false', '0'):
                self.positiveProjectionMethod = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('projectionAngle', node)
        if value is not None and 'projectionAngle' not in already_processed:
            already_processed.add('projectionAngle')
            try:
                self.projectionAngle = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (projectionAngle): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Projected3DProcessingParamaterSetType


class fieldFrequencyLockType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fieldFrequencyLockName=None):
        self.fieldFrequencyLockName = _cast(None, fieldFrequencyLockName)
        pass
    def factory(*args_, **kwargs_):
        if fieldFrequencyLockType.subclass:
            return fieldFrequencyLockType.subclass(*args_, **kwargs_)
        else:
            return fieldFrequencyLockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fieldFrequencyLockName(self): return self.fieldFrequencyLockName
    def set_fieldFrequencyLockName(self, fieldFrequencyLockName): self.fieldFrequencyLockName = fieldFrequencyLockName
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='fieldFrequencyLockType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fieldFrequencyLockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='fieldFrequencyLockType'):
        if self.fieldFrequencyLockName is not None and 'fieldFrequencyLockName' not in already_processed:
            already_processed.add('fieldFrequencyLockName')
            outfile.write(' fieldFrequencyLockName=%s' % (self.gds_format_string(quote_attrib(self.fieldFrequencyLockName).encode(ExternalEncoding), input_name='fieldFrequencyLockName'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='fieldFrequencyLockType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='fieldFrequencyLockType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fieldFrequencyLockName is not None and 'fieldFrequencyLockName' not in already_processed:
            already_processed.add('fieldFrequencyLockName')
            showIndent(outfile, level)
            outfile.write('fieldFrequencyLockName="%s",\n' % (self.fieldFrequencyLockName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldFrequencyLockName', node)
        if value is not None and 'fieldFrequencyLockName' not in already_processed:
            already_processed.add('fieldFrequencyLockName')
            self.fieldFrequencyLockName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fieldFrequencyLockType


class concentrationStandardType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, concentrationInSample=None, name=None):
        self.type_ = type_
        self.concentrationInSample = concentrationInSample
        self.name = name
    def factory(*args_, **kwargs_):
        if concentrationStandardType.subclass:
            return concentrationStandardType.subclass(*args_, **kwargs_)
        else:
            return concentrationStandardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_concentrationInSample(self): return self.concentrationInSample
    def set_concentrationInSample(self, concentrationInSample): self.concentrationInSample = concentrationInSample
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.concentrationInSample is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='concentrationStandardType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='concentrationStandardType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='concentrationStandardType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='concentrationStandardType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.concentrationInSample is not None:
            self.concentrationInSample.export(outfile, level, namespace_, name_='concentrationInSample', pretty_print=pretty_print)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='concentrationStandardType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.CVTermType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concentrationInSample is not None:
            showIndent(outfile, level)
            outfile.write('concentrationInSample=model_.ValueWithUnitType(\n')
            self.concentrationInSample.exportLiteral(outfile, level, name_='concentrationInSample')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.CVTermType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.type_ = obj_
        elif nodeName_ == 'concentrationInSample':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.concentrationInSample = obj_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name = obj_
# end class concentrationStandardType


class hadamardParameterSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hadamardFrequency=None):
        if hadamardFrequency is None:
            self.hadamardFrequency = []
        else:
            self.hadamardFrequency = hadamardFrequency
    def factory(*args_, **kwargs_):
        if hadamardParameterSetType.subclass:
            return hadamardParameterSetType.subclass(*args_, **kwargs_)
        else:
            return hadamardParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hadamardFrequency(self): return self.hadamardFrequency
    def set_hadamardFrequency(self, hadamardFrequency): self.hadamardFrequency = hadamardFrequency
    def add_hadamardFrequency(self, value): self.hadamardFrequency.append(value)
    def insert_hadamardFrequency(self, index, value): self.hadamardFrequency[index] = value
    def hasContent_(self):
        if (
            self.hadamardFrequency
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='hadamardParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hadamardParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='hadamardParameterSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='hadamardParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for hadamardFrequency_ in self.hadamardFrequency:
            hadamardFrequency_.export(outfile, level, namespace_, name_='hadamardFrequency', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='hadamardParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hadamardFrequency=[\n')
        level += 1
        for hadamardFrequency_ in self.hadamardFrequency:
            showIndent(outfile, level)
            outfile.write('model_.ValueWithUnitType(\n')
            hadamardFrequency_.exportLiteral(outfile, level, name_='ValueWithUnitType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hadamardFrequency':
            obj_ = ValueWithUnitType.factory()
            obj_.build(child_)
            self.hadamardFrequency.append(obj_)
# end class hadamardParameterSetType


class pulseSequenceFileRefListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pulseSequenceFileRef=None):
        if pulseSequenceFileRef is None:
            self.pulseSequenceFileRef = []
        else:
            self.pulseSequenceFileRef = pulseSequenceFileRef
    def factory(*args_, **kwargs_):
        if pulseSequenceFileRefListType.subclass:
            return pulseSequenceFileRefListType.subclass(*args_, **kwargs_)
        else:
            return pulseSequenceFileRefListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pulseSequenceFileRef(self): return self.pulseSequenceFileRef
    def set_pulseSequenceFileRef(self, pulseSequenceFileRef): self.pulseSequenceFileRef = pulseSequenceFileRef
    def add_pulseSequenceFileRef(self, value): self.pulseSequenceFileRef.append(value)
    def insert_pulseSequenceFileRef(self, index, value): self.pulseSequenceFileRef[index] = value
    def hasContent_(self):
        if (
            self.pulseSequenceFileRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='pulseSequenceFileRefListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pulseSequenceFileRefListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='pulseSequenceFileRefListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='pulseSequenceFileRefListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pulseSequenceFileRef_ in self.pulseSequenceFileRef:
            pulseSequenceFileRef_.export(outfile, level, namespace_, name_='pulseSequenceFileRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='pulseSequenceFileRefListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pulseSequenceFileRef=[\n')
        level += 1
        for pulseSequenceFileRef_ in self.pulseSequenceFileRef:
            showIndent(outfile, level)
            outfile.write('model_.SourceFileRefType(\n')
            pulseSequenceFileRef_.exportLiteral(outfile, level, name_='SourceFileRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pulseSequenceFileRef':
            obj_ = SourceFileRefType.factory()
            obj_.build(child_)
            self.pulseSequenceFileRef.append(obj_)
# end class pulseSequenceFileRefListType


class processingParameterSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, postAcquisitionSolventSuppressionMethod=None, calibrationCompound=None, dataTransformationMethod=None):
        self.postAcquisitionSolventSuppressionMethod = postAcquisitionSolventSuppressionMethod
        self.calibrationCompound = calibrationCompound
        self.dataTransformationMethod = dataTransformationMethod
    def factory(*args_, **kwargs_):
        if processingParameterSetType.subclass:
            return processingParameterSetType.subclass(*args_, **kwargs_)
        else:
            return processingParameterSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_postAcquisitionSolventSuppressionMethod(self): return self.postAcquisitionSolventSuppressionMethod
    def set_postAcquisitionSolventSuppressionMethod(self, postAcquisitionSolventSuppressionMethod): self.postAcquisitionSolventSuppressionMethod = postAcquisitionSolventSuppressionMethod
    def get_calibrationCompound(self): return self.calibrationCompound
    def set_calibrationCompound(self, calibrationCompound): self.calibrationCompound = calibrationCompound
    def get_dataTransformationMethod(self): return self.dataTransformationMethod
    def set_dataTransformationMethod(self, dataTransformationMethod): self.dataTransformationMethod = dataTransformationMethod
    def hasContent_(self):
        if (
            self.postAcquisitionSolventSuppressionMethod is not None or
            self.calibrationCompound is not None or
            self.dataTransformationMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='processingParameterSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='processingParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='processingParameterSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='processingParameterSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.postAcquisitionSolventSuppressionMethod is not None:
            self.postAcquisitionSolventSuppressionMethod.export(outfile, level, namespace_, name_='postAcquisitionSolventSuppressionMethod', pretty_print=pretty_print)
        if self.calibrationCompound is not None:
            self.calibrationCompound.export(outfile, level, namespace_, name_='calibrationCompound', pretty_print=pretty_print)
        if self.dataTransformationMethod is not None:
            self.dataTransformationMethod.export(outfile, level, namespace_, name_='dataTransformationMethod', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='processingParameterSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.postAcquisitionSolventSuppressionMethod is not None:
            showIndent(outfile, level)
            outfile.write('postAcquisitionSolventSuppressionMethod=model_.CVTermType(\n')
            self.postAcquisitionSolventSuppressionMethod.exportLiteral(outfile, level, name_='postAcquisitionSolventSuppressionMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calibrationCompound is not None:
            showIndent(outfile, level)
            outfile.write('calibrationCompound=model_.CVTermType(\n')
            self.calibrationCompound.exportLiteral(outfile, level, name_='calibrationCompound')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataTransformationMethod is not None:
            showIndent(outfile, level)
            outfile.write('dataTransformationMethod=model_.CVTermType(\n')
            self.dataTransformationMethod.exportLiteral(outfile, level, name_='dataTransformationMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'postAcquisitionSolventSuppressionMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.postAcquisitionSolventSuppressionMethod = obj_
        elif nodeName_ == 'calibrationCompound':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.calibrationCompound = obj_
        elif nodeName_ == 'dataTransformationMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.dataTransformationMethod = obj_
# end class processingParameterSetType


class windowFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, windowFunctionMethod=None, windowFunctionParameter=None):
        self.windowFunctionMethod = windowFunctionMethod
        if windowFunctionParameter is None:
            self.windowFunctionParameter = []
        else:
            self.windowFunctionParameter = windowFunctionParameter
    def factory(*args_, **kwargs_):
        if windowFunctionType.subclass:
            return windowFunctionType.subclass(*args_, **kwargs_)
        else:
            return windowFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_windowFunctionMethod(self): return self.windowFunctionMethod
    def set_windowFunctionMethod(self, windowFunctionMethod): self.windowFunctionMethod = windowFunctionMethod
    def get_windowFunctionParameter(self): return self.windowFunctionParameter
    def set_windowFunctionParameter(self, windowFunctionParameter): self.windowFunctionParameter = windowFunctionParameter
    def add_windowFunctionParameter(self, value): self.windowFunctionParameter.append(value)
    def insert_windowFunctionParameter(self, index, value): self.windowFunctionParameter[index] = value
    def hasContent_(self):
        if (
            self.windowFunctionMethod is not None or
            self.windowFunctionParameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='windowFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='windowFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='windowFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dx:', name_='windowFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.windowFunctionMethod is not None:
            self.windowFunctionMethod.export(outfile, level, namespace_, name_='windowFunctionMethod', pretty_print=pretty_print)
        for windowFunctionParameter_ in self.windowFunctionParameter:
            windowFunctionParameter_.export(outfile, level, namespace_, name_='windowFunctionParameter', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='windowFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.windowFunctionMethod is not None:
            showIndent(outfile, level)
            outfile.write('windowFunctionMethod=model_.CVTermType(\n')
            self.windowFunctionMethod.exportLiteral(outfile, level, name_='windowFunctionMethod')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('windowFunctionParameter=[\n')
        level += 1
        for windowFunctionParameter_ in self.windowFunctionParameter:
            showIndent(outfile, level)
            outfile.write('model_.CVParamType(\n')
            windowFunctionParameter_.exportLiteral(outfile, level, name_='CVParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'windowFunctionMethod':
            class_obj_ = self.get_class_obj_(child_, CVTermType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.windowFunctionMethod = obj_
        elif nodeName_ == 'windowFunctionParameter':
            obj_ = CVParamType.factory()
            obj_.build(child_)
            self.windowFunctionParameter.append(obj_)
# end class windowFunctionType


class ContactType(ParamGroupType):
    """A person's name and information on how to communicate with them.An
    identifier for this contact .Name of the contact person.Uniform
    Resource Locator related to the contact person or
    organization.Postal address of the contact person or
    organization.Home institution of the contact person.Email
    address of the contact person or organization."""
    subclass = None
    superclass = ParamGroupType
    def __init__(self, referenceableParamGroupRef=None, cvParam=None, cvParamWithUnit=None, cvTerm=None, userParam=None, url=None, id=None, address=None, organization=None, fullname=None, email=None):
        super(ContactType, self).__init__(referenceableParamGroupRef, cvParam, cvParamWithUnit, cvTerm, userParam, )
        self.url = _cast(None, url)
        self.id = _cast(None, id)
        self.address = _cast(None, address)
        self.organization = _cast(None, organization)
        self.fullname = _cast(None, fullname)
        self.email = _cast(None, email)
        pass
    def factory(*args_, **kwargs_):
        if ContactType.subclass:
            return ContactType.subclass(*args_, **kwargs_)
        else:
            return ContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_organization(self): return self.organization
    def set_organization(self, organization): self.organization = organization
    def get_fullname(self): return self.fullname
    def set_fullname(self, fullname): self.fullname = fullname
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def hasContent_(self):
        if (
            super(ContactType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dx:', name_='ContactType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dx:', name_='ContactType'):
        super(ContactType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ContactType')
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.address is not None and 'address' not in already_processed:
            already_processed.add('address')
            outfile.write(' address=%s' % (self.gds_format_string(quote_attrib(self.address).encode(ExternalEncoding), input_name='address'), ))
        if self.organization is not None and 'organization' not in already_processed:
            already_processed.add('organization')
            outfile.write(' organization=%s' % (self.gds_format_string(quote_attrib(self.organization).encode(ExternalEncoding), input_name='organization'), ))
        if self.fullname is not None and 'fullname' not in already_processed:
            already_processed.add('fullname')
            outfile.write(' fullname=%s' % (self.gds_format_string(quote_attrib(self.fullname).encode(ExternalEncoding), input_name='fullname'), ))
        if self.email is not None and 'email' not in already_processed:
            already_processed.add('email')
            outfile.write(' email=%s' % (self.gds_format_string(quote_attrib(self.email).encode(ExternalEncoding), input_name='email'), ))
    def exportChildren(self, outfile, level, namespace_='dx:', name_='ContactType', fromsubclass_=False, pretty_print=True):
        super(ContactType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ContactType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            showIndent(outfile, level)
            outfile.write('url="%s",\n' % (self.url,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.address is not None and 'address' not in already_processed:
            already_processed.add('address')
            showIndent(outfile, level)
            outfile.write('address="%s",\n' % (self.address,))
        if self.organization is not None and 'organization' not in already_processed:
            already_processed.add('organization')
            showIndent(outfile, level)
            outfile.write('organization="%s",\n' % (self.organization,))
        if self.fullname is not None and 'fullname' not in already_processed:
            already_processed.add('fullname')
            showIndent(outfile, level)
            outfile.write('fullname="%s",\n' % (self.fullname,))
        if self.email is not None and 'email' not in already_processed:
            already_processed.add('email')
            showIndent(outfile, level)
            outfile.write('email="%s",\n' % (self.email,))
        super(ContactType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ContactType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.add('address')
            self.address = value
        value = find_attr_value_('organization', node)
        if value is not None and 'organization' not in already_processed:
            already_processed.add('organization')
            self.organization = value
        value = find_attr_value_('fullname', node)
        if value is not None and 'fullname' not in already_processed:
            already_processed.add('fullname')
            self.fullname = value
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.add('email')
            self.email = value
        super(ContactType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ContactType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ContactType


GDSClassesMapping = {
    'gammaB1PulseFieldStrength': ValueWithUnitType,
    'concentrationInSample': ValueWithUnitType,
    'softwareRef': SoftwareRefType,
    'encodingScheme': CVParamType,
    'fileDescription': FileDescriptionType,
    'dataTransformationMethod': CVTermType,
    'firstDimensionProcessingParameterSet': FirstDimensionProcessingParameterSetType,
    'chemicalShiftStandard': CVParamType,
    'name': CVTermType,
    'sourceFileList': SourceFileListType,
    'processingParameterSet': processingParameterSetType,
    'additionalSoluteList': AdditionalSoluteListType,
    'sourceFile': SourceFileType,
    'pulseSequenceFileRefList': pulseSequenceFileRefListType,
    'higherDimensionParameterSet': HigherDimensionProcessingParameterSetType,
    'pulseSequenceFileRef': SourceFileRefType,
    'softwareList': SoftwareListType,
    'referenceableParamGroupList': ReferenceableParamGroupListType,
    'pulseSequence': PulseSequenceType,
    'windowFunctionMethod': CVTermType,
    'solventType': CVTermType,
    'acquisitionParameterSet': AcquisitionParameterSetMultiDType,
    'calibrationReferenceShift': ValueWithUnitType,
    'DirectDimensionParameterSet': AcquisitionDimensionParameterSetType,
    'solventSuppressionMethod': CVParamType,
    'acquisitionParameterFileRefList': SourceFileRefListType,
    'dataProcessing': DataProcessingType,
    'spectrumDataArray': BinaryDataArrayType,
    'processingContactRefList': ContactRefListType,
    'fileContent': ParamGroupType,
    'samplingStrategy': CVTermType,
    'baselineCorrectionMethod': CVTermType,
    'acquisition1D': Acquisition1DType,
    'sourceFileRef': SourceFileRefType,
    'solute': SoluteType,
    'sampleAcquisitionTemperature': ValueWithUnitType,
    'processingMethod': ProcessingMethodType,
    'relaxationDelay': ValueWithUnitType,
    'directDimensionParameterSet': FirstDimensionProcessingParameterSetType,
    'spectrumMultiD': SpectrumMultiDType,
    'fieldFrequencyLock': fieldFrequencyLockType,
    'calibrationCompound': CVTermType,
    'zeroOrderPhaseCorrection': ValueWithUnitType,
    'instrumentConfigurationList': InstrumentConfigurationListType,
    'cv': CVType,
    'spinningRate': ValueWithUnitType,
    'cvParam': CVParamType,
    'spectrum1D': Spectrum1DType,
    'userParam': UserParamType,
    'projected3DProcessingParamaterSet': Projected3DProcessingParamaterSetType,
    'type': CVTermType,
    'nmrML': nmrMLType,
    'cvList': CVListType,
    'encodingMethod': CVTermType,
    'decouplingMethod': CVTermType,
    'xAxis': AxisWithUnitType,
    'contactList': ContactListType,
    'projectionMethod': CVTermType,
    'higherDimensionProcessingParameterSet': HigherDimensionProcessingParameterSetType,
    'sample': SampleType,
    'contactRefList': ContactRefListType,
    'parameterFileRef': SourceFileRefType,
    'windowFunctionParameter': CVParamType,
    'shapedPulseFile': SourceFileRefType,
    'hadamardParameterSet': hadamardParameterSetType,
    'yAxisType': CVTermType,
    'concentrationStandard': concentrationStandardType,
    'acquisition': AcquisitionType,
    'cvParamWithUnit': CVParamWithUnitType,
    'spectrumList': SpectrumListType,
    'sampleContainer': CVTermType,
    'fidData': BinaryDataArrayType,
    'sampleList': SampleListType,
    'windowFunction': windowFunctionType,
    'irradiationFrequency': ValueWithUnitType,
    'acquisitionNucleus': CVTermType,
    'postAcquisitionSolventSuppressionMethod': CVTermType,
    'spectralDenoisingMethod': CVTermType,
    'sweepWidth': ValueWithUnitType,
    'firstOrderPhaseCorrection': ValueWithUnitType,
    'indirectDimensionParameterSet': AcquisitionDimensionParameterSetType,
    'contact': ContactType,
    'hadamardFrequency': ValueWithUnitType,
    'processingSoftwareRefList': SoftwareRefListType,
    'contactRef': ContactRefType,
    'solventConcentration': ValueWithUnitType,
    'referenceableParamGroupRef': ReferenceableParamGroupRefType,
    'buffer': CVTermType,
    'timeDomain': BinaryDataArrayType,
    'instrumentConfiguration': InstrumentConfigurationType,
    'samplingTimePoints': BinaryDataArrayType,
    'dataProcessingList': DataProcessingListType,
    'referenceableParamGroup': ReferenceableParamGroupType,
    'cvTerm': CVTermType,
    'software': SoftwareType,
    'acquisitionMultiD': AcquisitionMultiDType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nmrML'
        rootClass = nmrML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:dx="http://nmrml.org/schema"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nmrML'
        rootClass = nmrML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = nmrML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_="nmrML",
            namespacedef_='xmlns:dx="http://nmrml.org/schema"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nmrML'
        rootClass = nmrML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from nmrML_lib import *\n\n')
        sys.stdout.write('import nmrML_lib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Acquisition1DType",
    "AcquisitionDimensionParameterSetType",
    "AcquisitionIndirectDimensionParameterSetType",
    "AcquisitionMultiDType",
    "AcquisitionParameterSet1DType",
    "AcquisitionParameterSetMultiDType",
    "AcquisitionParameterSetType",
    "AcquisitionType",
    "AdditionalSoluteListType",
    "AxisWithUnitType",
    "BinaryDataArrayType",
    "CVListType",
    "CVParamType",
    "CVParamWithUnitType",
    "CVTermType",
    "CVType",
    "ContactListType",
    "ContactRefListType",
    "ContactRefType",
    "ContactType",
    "DataProcessingListType",
    "DataProcessingType",
    "FileDescriptionType",
    "FirstDimensionProcessingParameterSetType",
    "HigherDimensionProcessingParameterSetType",
    "InstrumentConfigurationListType",
    "InstrumentConfigurationType",
    "ParamGroupType",
    "ProcessingMethodType",
    "Projected3DProcessingParamaterSetType",
    "PulseSequenceType",
    "ReferenceableParamGroupListType",
    "ReferenceableParamGroupRefType",
    "ReferenceableParamGroupType",
    "SampleListType",
    "SampleType",
    "SoftwareListType",
    "SoftwareRefListType",
    "SoftwareRefType",
    "SoftwareType",
    "SoluteType",
    "SourceFileListType",
    "SourceFileRefListType",
    "SourceFileRefType",
    "SourceFileType",
    "SpectralProcessingParameterSet2DType",
    "SpectralProcessingParameterSetType",
    "SpectralProjectionParameterSetType",
    "Spectrum1DType",
    "SpectrumListType",
    "SpectrumMultiDType",
    "SpectrumType",
    "TemperatureType",
    "UserParamType",
    "ValueWithUnitType",
    "concentrationStandardType",
    "fieldFrequencyLockType",
    "hadamardParameterSetType",
    "nmrMLType",
    "processingParameterSetType",
    "pulseSequenceFileRefListType",
    "windowFunctionType"
]
